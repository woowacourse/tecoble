{"componentChunkName":"component---src-templates-post-tsx","path":"/post/2021-07-11-suspense/","result":{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwUlEQVQY003Qvw7BUBTH8YYgLCKExWw1IczEwAtIJCa1GJuyCalI/EmERUgHi5cxeI8uTTt1aHp9r9wmhk/OOfee/HJzNd/3Dc/zutS24zgZIUQpiqIt9YY+vUb9+eur6Kh5GN9LGkEn2DBd1y1zmGfxjjf9AFm1XEQCBe6aVBMVLJHiLBcHTiHwQS0MQ/mSOlYsjPDCAjOMccUFR3Z0NdvYISkDW9jAQi8IAhnYgAyZ4wELEzUfcFZfYmCPJ9ZIfwG9owW1fLgCkwAAAABJRU5ErkJggg==","width":400,"height":88,"src":"/static/0b18bd94a62a12fdc81ea720c28722f6/3891b/tecoble.png","srcSet":"/static/0b18bd94a62a12fdc81ea720c28722f6/3891b/tecoble.png 1x"}}},"markdownRemark":{"html":"<h2>📜 읽기 전에…</h2>\n<ul>\n<li>🎈 본문에 등장하는 문제에 대한 예시는 suspense를 사용하지 않고도 해결할 수 있습니다.\n하지만 앱이 커지고 복잡해짐에 따라 각 문제를 어떻게 <code class=\"language-text\">선언적으로 손쉽게 해결할 수 있느냐에 대한 관점</code>으로 봐주시길 바랍니다.</li>\n<li>🎈 2021.07.11 기준 시험적인 기능입니다. 현재 정식 버전에서 suspense는 code splitting으로만 사용되고 있습니다. 유의해주세요.</li>\n<li>🎈 본문은 <a href=\"https://ko.reactjs.org/docs/concurrent-mode-suspense.html#what-suspense-lets-you-do\">리액트 공식 문서</a>를 참고하여 재구성하였음을 알립니다.</li>\n</ul>\n<h2>🙋‍♂️ suspense가 뭐죠?</h2>\n<p><strong>혹시 웹페이지에 로딩 화면을 만들어 본 적이 있나요?</strong></p>\n<p>대부분 사용자에게 무언가 진행되고 있음을 알리기 위해서 로딩 화면을 띄워본 경험이 있을 것이다.\nreact suspense는 이러한 로딩 화면과 연관이 있으며 다음과 같이 정의할 수 있다.</p>\n<blockquote>\n<p>특정 컴포넌트에서 사용되고 있는 데이터의 준비가 아직 끝나지 않았음을\nreact에 알릴 수 있으며 <code class=\"language-text\">data fetching 라이브러리</code>와 함께 사용할 수 있는 구조.</p>\n</blockquote>\n<p>위의 정의에서 <code class=\"language-text\">데이터의 준비가 끝나지 않았음을 알린다</code>라는 것은 해당 데이터를 사용하는 컴포넌트를\n렌더링하지 않고 다른 로딩 화면을 보여줄 수 있음을 의미한다.</p>\n<p>여기서 누군가는 의아할지도 모른다.\n<code class=\"language-text\">지금까지 suspense 없이도 로딩 화면을 잘 만들어 왔는데?</code> 라고 할지도 모른다.\n그렇다면 지금까지 만들어왔던 방식보다 suspense가 왜 좋은지 같이 알아보도록 하자.</p>\n<h2>👀 왜 사용하는 건가요?</h2>\n<p>앞서 설명한 것처럼 suspense는 <code class=\"language-text\">data fetching 라이브러리</code>와 함께 사용하면 효과적인 구조다.\n그렇다면 data fetching 라이브러리를 사용했을 때, 기존 방식보다 좋은 이유는 무엇인지부터 우선으로 알아보자.</p>\n<h3>data fetching 라이브러리의 역할</h3>\n<p>fetching 라이브러리는 <code class=\"language-text\">워터폴(waterfall)</code> 현상을 막아준다.\n워터폴이라고 하면 이전 개발 과정이 끝나야 다음 과정을 진행할 수 있는 프로젝트 방법론을 떠올리는 사람이 많을 것이다.\n하지만 fetching 라이브러리에서의 워터폴 현상은 이전 fetch 요청에 대한 응답이 도착해야\n다음 fetch 요청을 보낼 수 있는 구조를 의미한다.\n예를 들어 다음과 같은 상황이 있다고 생각해보자.</p>\n<ul>\n<li>컴포넌트 1에서 데이터 1을 요청… 가져오는 동안 로딩 화면만을 렌더링(3초 소요)</li>\n<li>컴포넌트 1에서 데이터 1의 응답을 받고 컴포넌트 2를 렌더링</li>\n<li>컴포넌트 2에서 데이터 2를 요청… 가져오는 동안 로딩 화면만을 렌더링(2초 소요)</li>\n<li>컴포넌트 2에서 데이터 2의 응답을 받고 컴포넌트 3을 렌더링</li>\n</ul>\n<p>이 상황에서 무조건 데이터 1에 대한 응답을 받고 나서야 데이터 2에 대한 요청이 실행된다.\n데이터 2에 대한 요청 자체는 2초만 소요됨에도 불구하고 데이터 1에 대한 요청 때문에\n3초를 무조건 기다려야 하는 문제가 발생하는 것이다. <a href=\"https://codesandbox.io/s/fragrant-glade-8huj6\">참고 코드</a></p>\n<p>이러한 문제는 <code class=\"language-text\">컴포넌트 렌더링 -> data fetching 요청 -> data 응답</code>과 같이 동작하는 구조 때문에 일어난다.\n이 문제를 <code class=\"language-text\">data fetching 라이브러리</code>는 컴포넌트 트리 구조에 필요한 모든 data fetching 요청을 렌더링 이전에\n실행하도록 중앙화하여 해결한다. 즉 <code class=\"language-text\">data fetching 요청 -> data 응답 -> 컴포넌트 렌더링</code>의 구조로 바뀌는 것이다.</p>\n<p>이렇게 구조가 바뀌면 data fetching 요청이 컴포넌트 렌더링에 의존되지 않고 모두 한 번에 실행되므로\n워터폴 현상을 막을 수 있다.</p>\n<p>그렇다면 data fetching 라이브러리만으로 모든 문제가 해결될까? 그건 아니었다.\n컴포넌트에 필요한 모든 data 응답을 받을 때까지 해당 컴포넌트는 물론이고 하위 컴포넌트들도 렌더링할 수 없다는 점이 문제였다. 또한 하위 컴포넌트들의 로딩도 의미가 없어져 버렸다. 하위 컴포넌트가 렌더링 된 시점에서는 상위 컴포넌트에 의해 이미 모든 데이터를 응답받은 상태이기 때문에 하위 컴포넌트의 로딩은 절대 렌더링 되지 않을 것이다.</p>\n<p><a href=\"https://codesandbox.io/s/wandering-morning-ev6r0\">참고코드</a></p>\n<p>사실 위 참고 코드에서는 <code class=\"language-text\">Promise.all()</code>을 사용하고 있는데 굳이 Promise.all()을 사용하지 않고\n따로 fetching 요청을 나누어도 이 문제에 대한 해결이 가능하다. 하지만 이렇게 따로 나누는 방식은\n데이터와 컴포넌트 트리가 복잡해짐에 따라 점점 어려워진다. 개발자들은 좀 더 간단한 방식을 원했다.</p>\n<p>여기서 suspense가 등장한다.</p>\n<h3>suspense의 역할</h3>\n<p>suspense의 역할은 크게 2가지로 나눌 수 있다. 하나씩 알아보자.</p>\n<p><strong>✨ 1. 모든 요청을 기다리지 않고도 화면을 렌더링할 수 있다.</strong></p>\n<p>앞서 fetching 라이브러리만을 사용했을 때 구조를 다시 보자.</p>\n<p><code class=\"language-text\">data fetching 요청 -> data 응답 -> 컴포넌트 렌더링</code></p>\n<p>이 과정을 좀 더 자세히 들여다 보면 다음과 같다.</p>\n<p><code class=\"language-text\">data fetching 요청 -> 로딩중 UI 렌더링 -> data 응답 -> 컴포넌트에 응답 반영</code></p>\n<p>이러한 구조에서 suspense는 요청 직후 <code class=\"language-text\">요청 리소스</code>를 바로 컴포넌트로 주입하는 방식으로 바꿔준다.</p>\n<p><code class=\"language-text\">data fetching 요청 -> suspense 하위의 컴포넌트에 요청 리소스를 반영 -> suspense에 의해 로딩 UI 렌더 -> 요청 리소스로 data 응답이 들어옴 -> 컴포넌트에 응답 반영</code></p>\n<p>여기서 말하는 요청 리소스는 <code class=\"language-text\">Promise의 형태가 아니다.</code>\ndata fetching 라이브러리 내부적으로 구현되어있는 일반 객체인데\nfetch API로 모방한 형태가 궁금하다면 <a href=\"https://codesandbox.io/s/trusting-clarke-8twuq?file=/src/fakeApi.js\">여기</a>를 참고하자.</p>\n<p>이런 구조로 바뀌면 fetching 라이브러리만 사용했을 때 모든 data 응답을 기다려야 컴포넌트 트리를\n렌더링할 수 있었던 문제를 해결할 수 있다. fetching 요청 직후 응답 도착 여부와는 상관없이 렌더링을 수행하기 때문이다.</p>\n<p><strong>✨ 2. 경쟁 상태 발생을 방지한다.</strong></p>\n<p>suspense는 data fetching에 의한 <code class=\"language-text\">경쟁 상태(Race Condition)</code> 발생을 방지한다.</p>\n<p>우선 경쟁 상태라는 용어부터 알아보자.\n<a href=\"https://ko.wikipedia.org/wiki/%EA%B2%BD%EC%9F%81_%EC%83%81%ED%83%9C\">위키백과</a>에서는 이렇게 설명하고 있다.</p>\n<blockquote>\n<p><code class=\"language-text\">공유 자원</code>에 대해 여러 개의 프로세스가 <code class=\"language-text\">동시에 접근</code>을 시도할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태</p>\n</blockquote>\n<p>그렇다면 javascript 환경에서 경쟁 상태란 무엇일까?\n여러 개의 비동기 작업(fetching response)의 결과가 하나의 DOM 객체에 반영되는 상황이 있을 것이다.</p>\n<p>예를 들어 다음과 같은 상황을 가정해보자.</p>\n<ul>\n<li>미키, 주모, 심바, 파노, 카일 5개의 버튼이 있고 각 버튼을 누르면 각 크루에 대한 프로필을 서버로 요청한다.</li>\n<li>프로필 요청 응답을 앱이 받으면 해당 정보를 <Profile /> 컴포넌트에 업데이트한다.</li>\n</ul>\n<iframe src=\"https://codesandbox.io/embed/suspense-race-condition-2b9jr?fontsize=14&hidenavigation=1&theme=dark\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"suspense-race-condition\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<p>여기서 여러 버튼을 빠른 속도로 누른다고 생각해보자. 과연 마지막에 누른 버튼과 <Profile /> 컴포넌트의 정보는\n일치할까? 아마 마지막으로 누른 버튼이 미키 버튼이라고 해도 주모의 정보가 표시될 수 있을 것이다.</p>\n<p>이러한 문제는 왜 발생할까? 그 이유는 버튼을 누른 순서대로 프로필 요청에 대한 응답이 도착하고\n순서대로 <Profile />에 반영될 것이라는 잘못된 가정에서 발생한다.\nA 요청이 B 요청보다 먼저 수행되었다고 해서 무조건 A 요청에 대한 응답이 먼저 도착하는 것은 아니기 때문에 해당 가정은 잘못되었다.</p>\n<p>그렇다면 이 문제를 suspense는 어떻게 해결할 수 있을까.\nsuspense는 state 설정 시기를 바꾸어 이를 해결한다.</p>\n<p>이전의 코드는 <code class=\"language-text\">A 프로필 요청 -> 로딩 UI 렌더 -> A 프로필 응답 -> &lt;Profile />에 응답 반영</code>의 순서였다면\nsuspense는 이 과정을 <code class=\"language-text\">A 프로필 요청 -> &lt;Profile />에 A 프로필 요청 리소스 반영 -> suspense에 의해 A 요청에 대한 로딩 UI 렌더 -> 요청 리소스로 A 프로필 응답이 들어옴 -> &lt;Profile />에 응답 반영</code>으로 바꾼다.</p>\n<p>경쟁 상태를 이런 방식으로 해결 가능한 이유는\nsuspense가 응답이 언제 오는지, 시간에 대한 것을 고려하지 않아도 되기 때문이다.\n프로필을 요청함과 동시에 해당 요청 리소스를 <Profile />에 반영하기 때문에\n이전에 수행하고 있던 요청이 있더라도 해당 요청은 무시하고 새로운 요청으로 대체된다.</p>\n<p>suspense는 이를 통해 경쟁 상태를 해결할 수 있다.</p>\n<h2>🔍 suspense와 함께 사용되는 data fetching 라이브러리</h2>\n<p>거의 무조건 data fetching 라이브러리와 함께 사용하기 때문에 fetching 라이브러리와 suspense를 함께 사용하는 예시를 몇 가지 보도록 하자.</p>\n<h3>Relay</h3>\n<p>graphQL에 의존적인 data fetching 라이브러리다.</p>\n<p>페이스북에서는 suspense를 Relay와 함께 실무에서 사용하고 있다고 한다.\n그래서 Relay 외의 다른 라이브러리와 suspense를 사용했을 때 원활히 동작할지 장담할 수 없으므로\n만약 suspense를 실무에서 사용하고 싶다면 페이스북은 Relay와 함께 사용할 것을 추천하고 있다.</p>\n<p>만약 graphQL에 익숙하고 suspense 기능을 실무에서 사용해야 한다면 <a href=\"https://relay.dev/docs/getting-started/step-by-step-guide/\">Relay</a>를 쓰는 것이 적합할 것이다.</p>\n<h3>SWR</h3>\n<p>Data Fetching을 위한 react 훅 라이브러리인 SWR도 시험적으로 suspense를 지원하고 있다.\n간략하게 코드를 확인해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import { Suspense } from 'react'\nimport useSWR from 'swr'\n\nfunction Profile () {\n  const { data } = useSWR('/api/user', fetcher, { suspense: true })\n  return &lt;div>hello, {data.name}&lt;/div>\n}\n\nfunction App () {\n  return (\n    &lt;Suspense fallback={&lt;div>loading...&lt;/div>}>\n      &lt;Profile/>\n    &lt;/Suspense>\n  )\n}</code></pre></div>\n<p>useSWR의 세 번째 인자로 <code class=\"language-text\">suspense: true</code>를 전달함으로써 suspense 옵션을 활성화할 수 있다.\n이런 간단한 설정으로 suspense 사용이 가능하다.</p>\n<h3>그 외 suspense를 지원하는 라이브러리들</h3>\n<ul>\n<li><a href=\"https://react-query.tanstack.com/guides/suspense\">React Query</a></li>\n<li><a href=\"https://recoiljs.org/ko/docs/guides/asynchronous-data-queries/#asynchronous-example-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%98%88%EC%A0%9C\">Recoil</a></li>\n</ul>\n<h2>💕 마무리</h2>\n<p>사용자 경험 개선에 대한 주제로 아직 시험적인 기능이지만 React 18에서 추가될 기능인\nsuspense에 대해서 알아보았다. 공부를 하다 보니 비동기 동작이 얼마나 사용자 경험에 지대한 영향을 미칠 수 있는가에\n대해 새로운 인사이트를 얻을 수 있었다. 생각해보면 사용자가 기다리는 대부분의 시간은\ndata fetching과 관련이 있다. suspense를 통해 이 과정을 좀 더 효율적으로 처리할 수 있다면\n좀 더 쾌적한 경험을 사용자에게 줄 수 있을 것이다. 다음 2편에서는 이를 좀 더 개선할 수 있는\nconcurrent mode에 대해서 알아볼 예정이다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://ko.reactjs.org/docs/concurrent-mode-suspense.html\">리액트 공식 문서 - suspense</a></li>\n<li><a href=\"https://jbee.io/react/error-declarative-handling-1/\">React에서 선언적으로 비동기 다루기</a></li>\n<li><a href=\"https://github.com/reactwg/react-18/discussions/4\">리액트 18 소개</a></li>\n</ul>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"📜 읽기 전에…"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"🎈 본문에 등장하는 문제에 대한 예시는 suspense를 사용하지 않고도 해결할 수 있습니다.\n하지만 앱이 커지고 복잡해짐에 따라 각 문제를 어떻게 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"선언적으로 손쉽게 해결할 수 있느냐에 대한 관점"}]},{"type":"text","value":"으로 봐주시길 바랍니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"🎈 2021.07.11 기준 시험적인 기능입니다. 현재 정식 버전에서 suspense는 code splitting으로만 사용되고 있습니다. 유의해주세요."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"🎈 본문은 "},{"type":"element","tagName":"a","properties":{"href":"https://ko.reactjs.org/docs/concurrent-mode-suspense.html#what-suspense-lets-you-do"},"children":[{"type":"text","value":"리액트 공식 문서"}]},{"type":"text","value":"를 참고하여 재구성하였음을 알립니다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"🙋‍♂️ suspense가 뭐죠?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"혹시 웹페이지에 로딩 화면을 만들어 본 적이 있나요?"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"대부분 사용자에게 무언가 진행되고 있음을 알리기 위해서 로딩 화면을 띄워본 경험이 있을 것이다.\nreact suspense는 이러한 로딩 화면과 연관이 있으며 다음과 같이 정의할 수 있다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"특정 컴포넌트에서 사용되고 있는 데이터의 준비가 아직 끝나지 않았음을\nreact에 알릴 수 있으며 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"data fetching 라이브러리"}]},{"type":"text","value":"와 함께 사용할 수 있는 구조."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"위의 정의에서 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"데이터의 준비가 끝나지 않았음을 알린다"}]},{"type":"text","value":"라는 것은 해당 데이터를 사용하는 컴포넌트를\n렌더링하지 않고 다른 로딩 화면을 보여줄 수 있음을 의미한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"여기서 누군가는 의아할지도 모른다.\n"},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"지금까지 suspense 없이도 로딩 화면을 잘 만들어 왔는데?"}]},{"type":"text","value":" 라고 할지도 모른다.\n그렇다면 지금까지 만들어왔던 방식보다 suspense가 왜 좋은지 같이 알아보도록 하자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"👀 왜 사용하는 건가요?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"앞서 설명한 것처럼 suspense는 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"data fetching 라이브러리"}]},{"type":"text","value":"와 함께 사용하면 효과적인 구조다.\n그렇다면 data fetching 라이브러리를 사용했을 때, 기존 방식보다 좋은 이유는 무엇인지부터 우선으로 알아보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"data fetching 라이브러리의 역할"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"fetching 라이브러리는 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"워터폴(waterfall)"}]},{"type":"text","value":" 현상을 막아준다.\n워터폴이라고 하면 이전 개발 과정이 끝나야 다음 과정을 진행할 수 있는 프로젝트 방법론을 떠올리는 사람이 많을 것이다.\n하지만 fetching 라이브러리에서의 워터폴 현상은 이전 fetch 요청에 대한 응답이 도착해야\n다음 fetch 요청을 보낼 수 있는 구조를 의미한다.\n예를 들어 다음과 같은 상황이 있다고 생각해보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"컴포넌트 1에서 데이터 1을 요청… 가져오는 동안 로딩 화면만을 렌더링(3초 소요)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"컴포넌트 1에서 데이터 1의 응답을 받고 컴포넌트 2를 렌더링"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"컴포넌트 2에서 데이터 2를 요청… 가져오는 동안 로딩 화면만을 렌더링(2초 소요)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"컴포넌트 2에서 데이터 2의 응답을 받고 컴포넌트 3을 렌더링"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이 상황에서 무조건 데이터 1에 대한 응답을 받고 나서야 데이터 2에 대한 요청이 실행된다.\n데이터 2에 대한 요청 자체는 2초만 소요됨에도 불구하고 데이터 1에 대한 요청 때문에\n3초를 무조건 기다려야 하는 문제가 발생하는 것이다. "},{"type":"element","tagName":"a","properties":{"href":"https://codesandbox.io/s/fragrant-glade-8huj6"},"children":[{"type":"text","value":"참고 코드"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이러한 문제는 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"컴포넌트 렌더링 -> data fetching 요청 -> data 응답"}]},{"type":"text","value":"과 같이 동작하는 구조 때문에 일어난다.\n이 문제를 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"data fetching 라이브러리"}]},{"type":"text","value":"는 컴포넌트 트리 구조에 필요한 모든 data fetching 요청을 렌더링 이전에\n실행하도록 중앙화하여 해결한다. 즉 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"data fetching 요청 -> data 응답 -> 컴포넌트 렌더링"}]},{"type":"text","value":"의 구조로 바뀌는 것이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 구조가 바뀌면 data fetching 요청이 컴포넌트 렌더링에 의존되지 않고 모두 한 번에 실행되므로\n워터폴 현상을 막을 수 있다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그렇다면 data fetching 라이브러리만으로 모든 문제가 해결될까? 그건 아니었다.\n컴포넌트에 필요한 모든 data 응답을 받을 때까지 해당 컴포넌트는 물론이고 하위 컴포넌트들도 렌더링할 수 없다는 점이 문제였다. 또한 하위 컴포넌트들의 로딩도 의미가 없어져 버렸다. 하위 컴포넌트가 렌더링 된 시점에서는 상위 컴포넌트에 의해 이미 모든 데이터를 응답받은 상태이기 때문에 하위 컴포넌트의 로딩은 절대 렌더링 되지 않을 것이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://codesandbox.io/s/wandering-morning-ev6r0"},"children":[{"type":"text","value":"참고코드"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"사실 위 참고 코드에서는 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Promise.all()"}]},{"type":"text","value":"을 사용하고 있는데 굳이 Promise.all()을 사용하지 않고\n따로 fetching 요청을 나누어도 이 문제에 대한 해결이 가능하다. 하지만 이렇게 따로 나누는 방식은\n데이터와 컴포넌트 트리가 복잡해짐에 따라 점점 어려워진다. 개발자들은 좀 더 간단한 방식을 원했다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"여기서 suspense가 등장한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"suspense의 역할"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"suspense의 역할은 크게 2가지로 나눌 수 있다. 하나씩 알아보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"✨ 1. 모든 요청을 기다리지 않고도 화면을 렌더링할 수 있다."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"앞서 fetching 라이브러리만을 사용했을 때 구조를 다시 보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"data fetching 요청 -> data 응답 -> 컴포넌트 렌더링"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이 과정을 좀 더 자세히 들여다 보면 다음과 같다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"data fetching 요청 -> 로딩중 UI 렌더링 -> data 응답 -> 컴포넌트에 응답 반영"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이러한 구조에서 suspense는 요청 직후 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"요청 리소스"}]},{"type":"text","value":"를 바로 컴포넌트로 주입하는 방식으로 바꿔준다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"data fetching 요청 -> suspense 하위의 컴포넌트에 요청 리소스를 반영 -> suspense에 의해 로딩 UI 렌더 -> 요청 리소스로 data 응답이 들어옴 -> 컴포넌트에 응답 반영"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"여기서 말하는 요청 리소스는 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"Promise의 형태가 아니다."}]},{"type":"text","value":"\ndata fetching 라이브러리 내부적으로 구현되어있는 일반 객체인데\nfetch API로 모방한 형태가 궁금하다면 "},{"type":"element","tagName":"a","properties":{"href":"https://codesandbox.io/s/trusting-clarke-8twuq?file=/src/fakeApi.js"},"children":[{"type":"text","value":"여기"}]},{"type":"text","value":"를 참고하자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이런 구조로 바뀌면 fetching 라이브러리만 사용했을 때 모든 data 응답을 기다려야 컴포넌트 트리를\n렌더링할 수 있었던 문제를 해결할 수 있다. fetching 요청 직후 응답 도착 여부와는 상관없이 렌더링을 수행하기 때문이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"✨ 2. 경쟁 상태 발생을 방지한다."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"suspense는 data fetching에 의한 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"경쟁 상태(Race Condition)"}]},{"type":"text","value":" 발생을 방지한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"우선 경쟁 상태라는 용어부터 알아보자.\n"},{"type":"element","tagName":"a","properties":{"href":"https://ko.wikipedia.org/wiki/%EA%B2%BD%EC%9F%81_%EC%83%81%ED%83%9C"},"children":[{"type":"text","value":"위키백과"}]},{"type":"text","value":"에서는 이렇게 설명하고 있다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"공유 자원"}]},{"type":"text","value":"에 대해 여러 개의 프로세스가 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"동시에 접근"}]},{"type":"text","value":"을 시도할 때 접근의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그렇다면 javascript 환경에서 경쟁 상태란 무엇일까?\n여러 개의 비동기 작업(fetching response)의 결과가 하나의 DOM 객체에 반영되는 상황이 있을 것이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"예를 들어 다음과 같은 상황을 가정해보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"미키, 주모, 심바, 파노, 카일 5개의 버튼이 있고 각 버튼을 누르면 각 크루에 대한 프로필을 서버로 요청한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"프로필 요청 응답을 앱이 받으면 해당 정보를 "},{"type":"element","tagName":"profile","properties":{},"children":[{"type":"text","value":" 컴포넌트에 업데이트한다."}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"iframe","properties":{"src":"https://codesandbox.io/embed/suspense-race-condition-2b9jr?fontsize=14&hidenavigation=1&theme=dark","style":"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;","title":"suspense-race-condition","allow":"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking","sandbox":["allow-forms","allow-modals","allow-popups","allow-presentation","allow-same-origin","allow-scripts"]},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"여기서 여러 버튼을 빠른 속도로 누른다고 생각해보자. 과연 마지막에 누른 버튼과 "},{"type":"element","tagName":"profile","properties":{},"children":[{"type":"text","value":" 컴포넌트의 정보는\n일치할까? 아마 마지막으로 누른 버튼이 미키 버튼이라고 해도 주모의 정보가 표시될 수 있을 것이다."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이러한 문제는 왜 발생할까? 그 이유는 버튼을 누른 순서대로 프로필 요청에 대한 응답이 도착하고\n순서대로 "},{"type":"element","tagName":"profile","properties":{},"children":[{"type":"text","value":"에 반영될 것이라는 잘못된 가정에서 발생한다.\nA 요청이 B 요청보다 먼저 수행되었다고 해서 무조건 A 요청에 대한 응답이 먼저 도착하는 것은 아니기 때문에 해당 가정은 잘못되었다."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그렇다면 이 문제를 suspense는 어떻게 해결할 수 있을까.\nsuspense는 state 설정 시기를 바꾸어 이를 해결한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이전의 코드는 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"A 프로필 요청 -> 로딩 UI 렌더 -> A 프로필 응답 -> <Profile />에 응답 반영"}]},{"type":"text","value":"의 순서였다면\nsuspense는 이 과정을 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"A 프로필 요청 -> <Profile />에 A 프로필 요청 리소스 반영 -> suspense에 의해 A 요청에 대한 로딩 UI 렌더 -> 요청 리소스로 A 프로필 응답이 들어옴 -> <Profile />에 응답 반영"}]},{"type":"text","value":"으로 바꾼다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"경쟁 상태를 이런 방식으로 해결 가능한 이유는\nsuspense가 응답이 언제 오는지, 시간에 대한 것을 고려하지 않아도 되기 때문이다.\n프로필을 요청함과 동시에 해당 요청 리소스를 "},{"type":"element","tagName":"profile","properties":{},"children":[{"type":"text","value":"에 반영하기 때문에\n이전에 수행하고 있던 요청이 있더라도 해당 요청은 무시하고 새로운 요청으로 대체된다."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"suspense는 이를 통해 경쟁 상태를 해결할 수 있다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"🔍 suspense와 함께 사용되는 data fetching 라이브러리"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"거의 무조건 data fetching 라이브러리와 함께 사용하기 때문에 fetching 라이브러리와 suspense를 함께 사용하는 예시를 몇 가지 보도록 하자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Relay"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"graphQL에 의존적인 data fetching 라이브러리다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"페이스북에서는 suspense를 Relay와 함께 실무에서 사용하고 있다고 한다.\n그래서 Relay 외의 다른 라이브러리와 suspense를 사용했을 때 원활히 동작할지 장담할 수 없으므로\n만약 suspense를 실무에서 사용하고 싶다면 페이스북은 Relay와 함께 사용할 것을 추천하고 있다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"만약 graphQL에 익숙하고 suspense 기능을 실무에서 사용해야 한다면 "},{"type":"element","tagName":"a","properties":{"href":"https://relay.dev/docs/getting-started/step-by-step-guide/"},"children":[{"type":"text","value":"Relay"}]},{"type":"text","value":"를 쓰는 것이 적합할 것이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"SWR"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Data Fetching을 위한 react 훅 라이브러리인 SWR도 시험적으로 suspense를 지원하고 있다.\n간략하게 코드를 확인해보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"import { Suspense } from 'react'\nimport useSWR from 'swr'\n\nfunction Profile () {\n  const { data } = useSWR('/api/user', fetcher, { suspense: true })\n  return <div>hello, {data.name}</div>\n}\n\nfunction App () {\n  return (\n    <Suspense fallback={<div>loading...</div>}>\n      <Profile/>\n    </Suspense>\n  )\n}"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"useSWR의 세 번째 인자로 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"suspense: true"}]},{"type":"text","value":"를 전달함으로써 suspense 옵션을 활성화할 수 있다.\n이런 간단한 설정으로 suspense 사용이 가능하다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"그 외 suspense를 지원하는 라이브러리들"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://react-query.tanstack.com/guides/suspense"},"children":[{"type":"text","value":"React Query"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://recoiljs.org/ko/docs/guides/asynchronous-data-queries/#asynchronous-example-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%98%88%EC%A0%9C"},"children":[{"type":"text","value":"Recoil"}]}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"💕 마무리"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"사용자 경험 개선에 대한 주제로 아직 시험적인 기능이지만 React 18에서 추가될 기능인\nsuspense에 대해서 알아보았다. 공부를 하다 보니 비동기 동작이 얼마나 사용자 경험에 지대한 영향을 미칠 수 있는가에\n대해 새로운 인사이트를 얻을 수 있었다. 생각해보면 사용자가 기다리는 대부분의 시간은\ndata fetching과 관련이 있다. suspense를 통해 이 과정을 좀 더 효율적으로 처리할 수 있다면\n좀 더 쾌적한 경험을 사용자에게 줄 수 있을 것이다. 다음 2편에서는 이를 좀 더 개선할 수 있는\nconcurrent mode에 대해서 알아볼 예정이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"참고"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://ko.reactjs.org/docs/concurrent-mode-suspense.html"},"children":[{"type":"text","value":"리액트 공식 문서 - suspense"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://jbee.io/react/error-declarative-handling-1/"},"children":[{"type":"text","value":"React에서 선언적으로 비동기 다루기"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://github.com/reactwg/react-18/discussions/4"},"children":[{"type":"text","value":"리액트 18 소개"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"excerpt":"📜 읽기 전에… 🎈 본문에 등장하는 문제에 대한 예시는 suspense를 사용하지 않고도 해결할 수 있습니다.\n하지만 앱이 커지고 복잡해짐에 따라 각 문제를 어떻게 으로 봐주시길 바랍니다. 🎈 2021.07.1…","timeToRead":6,"frontmatter":{"title":"사용자 경험 개선 1편 - react suspense","userDate":"11 July 2021","date":"2021-07-11T12:00:00.000Z","tags":["suspense","react"],"excerpt":null,"image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAcIBf/EABYBAQEBAAAAAAAAAAAAAAAAAAIAA//aAAwDAQACEAMQAAABkJMSXuwYIjw6f//EABoQAAIDAQEAAAAAAAAAAAAAAAQFAAMGAgH/2gAIAQEAAQUCxQTTbLNSoBDZM3hgbMViwCnmk0XMsssu7//EABcRAQADAAAAAAAAAAAAAAAAAAACERL/2gAIAQMBAT8BxFb/xAAWEQEBAQAAAAAAAAAAAAAAAAAAESH/2gAIAQIBAT8B1H//xAAmEAACAgEDAwMFAAAAAAAAAAABAgMEEQUSIQATFAYiMSQyNUFR/9oACAEBAAY/ArtyOY1KUU6UJGiMTWTZeNJPbHYMXsELxskm/BfIIwhzPpQ9ReLqflJWtx6h3pYU7kcYFdfA0uTG8vDukFiQbN3941GuEiIhuTw/TWBFBms/iv2kkieQJvhYrv2kgg4wQzMKd65UDHLCrasVwWxjcRDImTjjJ/XHXt17WRyD+TuH4+PumPxjjppZneWR2LPJIxd3ZiWZmZslmZiSSeSTk9f/xAAbEAEAAwEAAwAAAAAAAAAAAAABABEhQTFhkf/aAAgBAQABPyGts1HXAkULYaBQv0gpGHyqSYq4tTZzjLDBRozgBfC0irFzORfRk+cgLpdKCuIJpHMm4LjlA9SRWf/aAAwDAQACAAMAAAAQd9//xAAdEQEAAgEFAQAAAAAAAAAAAAABESFBADFRYcGB/9oACAEDAQE/ELBgoAomu/NnONLVeWcHj3FuPv8A/8QAHBEBAQACAgMAAAAAAAAAAAAAAREhQQCBMVGh/9oACAECAQE/EKLHfzF7wzhIDMAeHRNIdwvrn//EABcQAQEBAQAAAAAAAAAAAAAAAAERACH/2gAIAQEAAT8QSyGvjp8JDEppBxujRzFHfPOOGSA6Bb34c6EF7JXwIqoTcqTD+MAGtBeUqIsACJpdtEKHvvJC/wD/2Q==","aspectRatio":1.5024232633279484,"src":"/static/b73ec6333ba89af789c008dd8eaf3c6d/5ef64/suspense.jpg","srcSet":"/static/b73ec6333ba89af789c008dd8eaf3c6d/0079a/suspense.jpg 930w,\n/static/b73ec6333ba89af789c008dd8eaf3c6d/8dba1/suspense.jpg 1860w,\n/static/b73ec6333ba89af789c008dd8eaf3c6d/5ef64/suspense.jpg 3720w,\n/static/b73ec6333ba89af789c008dd8eaf3c6d/47fcc/suspense.jpg 5580w,\n/static/b73ec6333ba89af789c008dd8eaf3c6d/9c507/suspense.jpg 6048w","sizes":"(max-width: 3720px) 100vw, 3720px"}}},"author":[{"id":"3기_미키","bio":"우아한테크코스 3기 미키(권세진)입니다 :)","avatar":{"children":[{"__typename":"ImageSharp","fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAYIBAf/xAAVAQEBAAAAAAAAAAAAAAAAAAAFA//aAAwDAQACEAMQAAABvlGyJbA3NiRhKf8A/8QAHRAAAAcAAwAAAAAAAAAAAAAAAAECAwQFBgcRFf/aAAgBAQABBQI/LUUxmtMKuM4sNx1daWtsXayJn+RJR//EACERAAEDAwQDAAAAAAAAAAAAAAECAxEAMVEEBhIhFCJB/9oACAEDAQE/AXthPcVL8hn1EwlLsmMX7wPtHYOkWeTepWEK7SFsuFQGCQ1BIyAJvAtX/8QAIhEAAQMDAwUAAAAAAAAAAAAAAQIDEQQSMQAHIRciQXGB/9oACAECAQE/AafcRBcQgMuJvMXOKbCROLiMCcnxnXUGpR2rbpbxwqH2wJ4wCskfSfev/8QAKBAAAgIBAgUCBwAAAAAAAAAAAQMCBBEAEgUTFCExBmE0QVGTsdHw/9oACAEBAAY/Avj6n3oj86li9T7fR6/3/eNCfXShuByudDiAasiUomDYRqz5bAY94E5AwT50Cxa5ewWkZ7ZwPAz28nAA99dR6fp0n8Vo2E3KdZ7W012WL3xals0uSh0eTKcunvcyk5kI8wZEGRt2QsUp2LjXOQviFTYHTisylHY6YxIbT3ln5a//xAAbEAEBAQEBAAMAAAAAAAAAAAABESEAMUFxsf/aAAgBAQABPyE58zL+sdtmhUQ4X4d+iqwV7flAAdqIGnCEcy4bv7fkHZFQg08/Q7MkChnxAPVIekxYx71gWqAHf//aAAwDAQACAAMAAAAQu9//xAAYEQEBAQEBAAAAAAAAAAAAAAABESExAP/aAAgBAwEBPxBFi6rLSBaisNIU75Y3qW0grQIMdc//xAAXEQEBAQEAAAAAAAAAAAAAAAABESEx/9oACAECAQE/EJAVLYwwA0CsCrihBMRHI0hBxiCJUr//xAAaEAEBAQEAAwAAAAAAAAAAAAABEQAhMUFR/9oACAEBAAE/EJMhAdpI2Ip8Z75uKdF4SgYkAOJFQz4oZPX83rSwFl0zIGWCGJQDGAxCAhhxY5eat52hqdYkWjADf//Z","aspectRatio":1.3333333333333333,"src":"/static/fa7f6a0c3d11e8c67baa396cbd962e43/2f1b1/mickey.jpg","srcSet":"/static/fa7f6a0c3d11e8c67baa396cbd962e43/b3d27/mickey.jpg 40w,\n/static/fa7f6a0c3d11e8c67baa396cbd962e43/5a735/mickey.jpg 80w,\n/static/fa7f6a0c3d11e8c67baa396cbd962e43/6e81a/mickey.jpg 120w,\n/static/fa7f6a0c3d11e8c67baa396cbd962e43/2f1b1/mickey.jpg 800w,\n/static/fa7f6a0c3d11e8c67baa396cbd962e43/c4b07/mickey.jpg 1440w","sizes":"(max-width: 800px) 100vw, 800px"}}]}}],"source":null}},"relatedPosts":{"totalCount":1,"edges":[{"node":{"id":"5dd365d4-6b03-503e-8b07-c0ef38abf620","timeToRead":6,"excerpt":"📜 읽기 전에… 🎈 본문에 등장하는 문제에 대한 예시는 suspense를 사용하지 않고도 해결할 수 있습니다.\n하지만 앱이 커지고 복잡해짐에 따라 각 문제를 어떻게 으로 봐주시길 바랍니다. 🎈 2021.07.1…","frontmatter":{"title":"사용자 경험 개선 1편 - react suspense","date":"2021-07-11T12:00:00.000Z"},"fields":{"slug":"/post/2021-07-11-suspense/"}}}]}},"pageContext":{"slug":"/post/2021-07-11-suspense/","prev":{"excerpt":"트랜잭션 이란? SQL을 사용하여 INSERT나 UPDATE 명령을 사용할 때 COMMIT을 해주어야 실제 데이터베이스에 반영이 된다. 트랜잭션에 대하여 아직 깊게 공부하지 않은 사람이라면 ‘나는 COMMIT…","timeToRead":3,"frontmatter":{"title":"Database Transaction","tags":["database","transaction"],"date":"2021-07-11T12:00:00.000Z","draft":false,"excerpt":null,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.7383177570093458,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABxklEQVQoz32T32/SUBTH+UN98cU3jT6YmGXxyRcfjMle92SMMZnRJZvDLFu2uWjmfqG4CBthsHZ0lLaUUloqpfd+LDChUPHcNCe959vvOd/b782QCCnlOIvbPSEEpmkSti7jQoS8rSexychMvckEoOcMk+cHVK5U2vVcXAynmv+FJkkz0wA5JBXxci+zBKeHdFptXMfG6vpDXGgcIzraeNL/Ego5Eloyv7L85Q5e9eewwYHi8v68iT/4Tv+Ot/GOfq2WIJshnHQaEQahz56yidkPebmj8GjljIVPZRb3atSdkNa3E9yqnpKemnAQTqBT1HeHPdcLNndf5dBUFaN2zWK2yItji2bU5khZJ+i5/5aclHvVzLF8+IBeZPAh3+Te61PsGxVbU3i2WeD5gY3brfD2x1PcoDGlLC05fhq6QdlqYkWQt/rcXynyZv+C1ZMKDz+W2boOibcxut582yR91Q9H1hD2ecy+T15r8SRb4fG2ylY9ZlJW4eZzarI5thnNOUi/1R0aR0sYfgcvNncnLhpnv9CyC1iltTGhlHPOcNZTvuezlq9TcyZmpnRBvqCxWx15UszITd+UmT/eF5JITKaQEwDz4g9QVpQtiHwFQQAAAABJRU5ErkJggg==","sizes":"(max-width: 1744px) 100vw, 1744px","src":"/static/34874978c05600cc52df5d8295775aed/19ed5/db-transaction.png","srcSet":"/static/34874978c05600cc52df5d8295775aed/3a443/db-transaction.png 930w,\n/static/34874978c05600cc52df5d8295775aed/19ed5/db-transaction.png 1744w"}}},"author":[{"id":"3기_영이","bio":"우아한테크코스 3기 영이(최준영)입니다 :)","avatar":{"children":[{"fluid":{"aspectRatio":1.3333333333333333,"base64":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAgFBgn/xAAWAQEBAQAAAAAAAAAAAAAAAAAFAgb/2gAMAwEAAhADEAAAAUsdGuxxluiZ3GnP/8QAGhAAAwEAAwAAAAAAAAAAAAAAAwQFBgECB//aAAgBAQABBQJdp3lmBqsOVuU55u5NLEzXZ1qZOtipYaWdn//EACERAAIBAwMFAAAAAAAAAAAAAAECAxESIQQFMQATMlGh/9oACAEDAQE/ATtGrgugVoyuoeix+QAjHdvBYDituDS5hUG3D7XuasVXSJIowHBjowx7mU/Bx1//xAAfEQACAQMFAQAAAAAAAAAAAAABAgMFERIABBMhYUH/2gAIAQIBAT8B2k1OybciWZBAiuFMYxDyScRBxZnZ27YXtZbnUVRozorNU+IsLmNoJcl8OMbL70T81//EACYQAAICAQMDAwUAAAAAAAAAAAIDAQQRBRIhABMUBiIyIzRBQlH/2gAIAQEABj8C2ARSitEiFpld71XK5dlh1/eEd4Cj5IZ7fiGP5Wv65phXrSqXj11tqLNAXDgl3bLO7KwgNs92WWP2IiSuSwcUW6in0vWOK4KrpbFd5DUVkE/cS1qxLBSKiYfE795Seel2A0hkbYOWMHU9RDtsyPjrVW8nxpRjfEqJUjHsiOI6HTk2PGjRHGposoLbLLDZZP1JiRBw8clO7diOB53SUUaQYERnxws1wKeZ3SsLwBvxMRMwA5xH556//8QAGBABAQEBAQAAAAAAAAAAAAAAAREhADH/2gAIAQEAAT8hAQLE8dh0t9eQelzwIrxJVLGu/ZXtwiECxoxhYs91DOwgL8b8G5yk2NIExSH1MHMK0hU76hnBYQr/2gAMAwEAAgADAAAAEIM//8QAGBEBAQEBAQAAAAAAAAAAAAAAAREhADH/2gAIAQMBAT8QuT3FDYoKqqsgPYJJHwEIZgprL407/8QAGBEBAQEBAQAAAAAAAAAAAAAAAREAITH/2gAIAQIBAT8QQEZZMgjdGHNvDB8uBrepcZEQPhE3/8QAFhABAQEAAAAAAAAAAAAAAAAAAQAh/9oACAEBAAE/EBs1JGSKpkBWiJP4UPuoQg7BVe7ctWzz4uJanA7tk9Dbii2jE59P5oFQ3bQcwoOCDoDY2Rf/2Q==","sizes":"(max-width: 800px) 100vw, 800px","src":"/static/56bc06af6518041e013d3ccfaedc1e8e/2f1b1/younge.jpg","srcSet":"/static/56bc06af6518041e013d3ccfaedc1e8e/fd013/younge.jpg 200w,\n/static/56bc06af6518041e013d3ccfaedc1e8e/25252/younge.jpg 400w,\n/static/56bc06af6518041e013d3ccfaedc1e8e/2f1b1/younge.jpg 800w,\n/static/56bc06af6518041e013d3ccfaedc1e8e/b1cc5/younge.jpg 960w"}}]}}]},"fields":{"layout":"post","slug":"/post/2021-07-11-database-transaction/"}},"next":{"excerpt":"자바로 작성된 코드는 어떻게 돌아가는 걸까?\n해당 물음에 답을 찾기 위한 JVM 시리즈 1편, JVM, JRE, JDK에 관한 글입니다.\n이번 글에서는 배포 환경 혹은 개발 환경을 세팅하면서 설치를 하였던 JRE와 JDK…","timeToRead":6,"frontmatter":{"title":"JVM에 관하여 - Part 1, JVM, JRE, JDK","tags":["jvm"],"date":"2021-07-12T12:00:00.000Z","draft":false,"excerpt":null,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.8552278820375334,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABJ0AAASdAHeZh94AAABnElEQVQoz4VTTU/CQBDl7xp/gEcT40W9eDDx5kET482DXpAEQvSAH6CgpAFBSilSKLS2lo+lu/tcClta0+ikzUxndt7O27dNYWGci4cvQ0aXfjIEpwS/60nGZK/wKRlw6WVxUE4EpIyh0R1CN7+gDWx8jhxMiR8HlCabmH4L1rwC96dhXtYqH5+4yBVxeVfBaeYRO2dpeFOyBgwWBg00mJJ18vAf9gPQ6NSSsWpYsCYMozFFzyGodW3MfZpAma+SvXvQ1xNw5VzOjeixBN9mGbAUwBbvpBNjl4oetm468GZzcEeF18xiQijafQtMnJsE9tUsSG4L5GYTs/QGSPF4tS9bU5agpXcduXIDz00DLy0TzniGu7dWjBJ3NRE5Qh1LoBtLH04YoSwtU6rjulBFQVEDRSllccEEtvtQwXelDrekwHtrrG9GKIowResLkDaKdR3pp1oQL+iajhdT2c7koW4foLN3hPeNLWi7h7FbEgKOhfQ9y0VNN1FtG8EGVdWAIXLRCYlhwrcdzEcWqPuN+UD8AEkq/2X/1aNrfgDpKktY2hQV8QAAAABJRU5ErkJggg==","sizes":"(max-width: 692px) 100vw, 692px","src":"/static/bf0e9d1bfd1c608bb1ebd0a02c5f083b/c7703/jvm-jre-jdk.png","srcSet":"/static/bf0e9d1bfd1c608bb1ebd0a02c5f083b/c7703/jvm-jre-jdk.png 692w"}}},"author":[{"id":"3기_와이비","bio":"우아한테크코스 3기 와이비(허영범)입니다 :)","avatar":{"children":[{"fluid":{"aspectRatio":1,"base64":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAYICQIF/8QAFgEBAQEAAAAAAAAAAAAAAAAABQYE/9oADAMBAAIQAxAAAAHKj3eImS3polLGtWqZkNVWfFmD/8QAHBAAAgIDAQEAAAAAAAAAAAAAAwUCBAEGEwcU/9oACAEBAAEFAjXCdYdwy8sWxta5lCVk/Njjjyg8g6dUx8ZkiRQwnQqgq0//xAAjEQABAwQBBAMAAAAAAAAAAAABAgMRABIhIkEEFTNRQkPR/9oACAEDAQE/AT0LTclbYkq1N4sNp3GJuBxBBCSMi4EGmGUBlrVI0GPUx+060127xN/R8E8lM8cyZ9yaUBJxya//xAAkEQEAAQMDAgcAAAAAAAAAAAABAgMREgAhMRMyFBUiI0Rhcf/aAAgBAgEBPwHx9eaRhWxCJkdNJxysx7rYp6sooo2Eilmc6jOSzZOTdZbrqjVq+bx9yp8g75cBsc8Fi34apb06a8sIK/eJr//EACgQAAIBAwMDAwUBAAAAAAAAAAECAwQREgUTIQAiQRQjMTIzQlJhUf/aAAgBAQAGPwKZO0bLOpt2/bfavYef2PySbnz1tVmdITEJo80PuRSx7sEi2uWSbt2yO1rg5Lzaonbuz1ap5t+lNRJ+X9U9apS0E0TRR1uoP6qcSxwhYZpHqFYRxSuJIFEz44Xmihd4Ve6g7cpcVDRxWYlhjAyxz0pjuM7Sw2cXxCoyJiGD2pZJrK9XW6jV/wCBg9W6BhfwRFx4sOtQNOdvPV6ipOPHvFK1A/FuVDvhf4LE+eq2bUNOpa+X0+me5WR7zd2Styx+SFHd9X95PVPTU0a09PAhjhhhAWONA7HFV8Dk9f/EABoQAQACAwEAAAAAAAAAAAAAAAERIQAxQWH/2gAIAQEAAT8h8KtACzQS0KJSa2Qey+nTNaCZgA8BuoxLr11qqiY44KAgrQcHwrLaKD0Fd2CMYSaEzoNdETdlUENAKMmqdJTqLTfh7ZSw/wCgd8UJ30HQE6zlHjCYGr3P/9oADAMBAAIAAwAAABAf14D/xAAZEQEBAQEBAQAAAAAAAAAAAAABEUEAIfD/2gAIAQMBAT8QCVNAXyEUKnbFQBwFqAAAQRcB8vHKAxUBpndAFgG14BgAAAAAUAMA8DO//8QAGhEBAQEBAQEBAAAAAAAAAAAAAREhADFhkf/aAAgBAgEBPxAS9EMAaaQ6NEHDqqlSgFWlaG+v5yBWLJT0/QIPBQ0IlRUhqpFV1V1XV3v/xAAYEAEBAQEBAAAAAAAAAAAAAAABEQAhMf/aAAgBAQABPxAbC0R2fXMQVmEbuCWQsiX1FjV7wGztY2yBTy2gLrq7HVG1USZ455KUw6lB4MIHIi654Sk1FGKySi53xXj1DuvyWJIrCnXA4rh5pkxGoLidAMM//9k=","sizes":"(max-width: 460px) 100vw, 460px","src":"/static/bfb773c24f06294935406a14cb053e4e/f86e8/whybe.jpg","srcSet":"/static/bfb773c24f06294935406a14cb053e4e/fd013/whybe.jpg 200w,\n/static/bfb773c24f06294935406a14cb053e4e/25252/whybe.jpg 400w,\n/static/bfb773c24f06294935406a14cb053e4e/f86e8/whybe.jpg 460w"}}]}}]},"fields":{"layout":"post","slug":"/post/2021-07-12-jvm-jre-jdk/"}},"primaryTag":"suspense"}},"staticQueryHashes":["2130001345","4041952199"]}