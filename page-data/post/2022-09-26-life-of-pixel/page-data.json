{"componentChunkName":"component---src-templates-post-tsx","path":"/post/2022-09-26-life-of-pixel/","result":{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwUlEQVQY003Qvw7BUBTH8YYgLCKExWw1IczEwAtIJCa1GJuyCalI/EmERUgHi5cxeI8uTTt1aHp9r9wmhk/OOfee/HJzNd/3Dc/zutS24zgZIUQpiqIt9YY+vUb9+eur6Kh5GN9LGkEn2DBd1y1zmGfxjjf9AFm1XEQCBe6aVBMVLJHiLBcHTiHwQS0MQ/mSOlYsjPDCAjOMccUFR3Z0NdvYISkDW9jAQi8IAhnYgAyZ4wELEzUfcFZfYmCPJ9ZIfwG9owW1fLgCkwAAAABJRU5ErkJggg==","width":400,"height":88,"src":"/static/0b18bd94a62a12fdc81ea720c28722f6/3891b/tecoble.png","srcSet":"/static/0b18bd94a62a12fdc81ea720c28722f6/3891b/tecoble.png 1x"}}},"markdownRemark":{"html":"<br>\n<p>이 글은 Google Chrome 개발자 Steve Kobes의 <a href=\"https://www.youtube.com/watch?v=K2QHdgAKP-s\">Life of Pixel영상</a>을 보고 정리한 내용입니다. 사용된 이미지들은 <a href=\"https://user-images.githubusercontent.com/52737532/195376209-a2eed93c-dbd1-4880-b051-bf33cd869cdf.png\" target=\"_blank\">Steve Kobes의 허락</a>\n하에 <a href=\"https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_6\">slide show</a>에서 가져왔습니다.</p>\n<br>\n<h1>이 글의 목표</h1>\n<ol>\n<li>어떤 과정을 통해 HTML파일이 화면에 그려지고, page가 되는지 이해합니다.</li>\n<li>composite에 대해 이해합니다.</li>\n<li>왜 layer를 분리하는것이 더 빠른 렌더링을 가능하게 하는지 이해합니다.</li>\n</ol>\n<h1>간단 요약</h1>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159612-0e7e1ae1-245e-4c9d-92ae-bef108f81aa2.png\" alt=\"sc_-36\"></p>\n<ol>\n<li>HTML content(index.html)를 불러옵니다.</li>\n<li>HTML Parser가 index.html을 parsing 하면서 DOM을 생성합니다. (DOM)</li>\n<li>style 자원을 만나면 CSS Parser가 parsing 후, 각 DOM 노드에 computedStyle을 적용합니다. (style)</li>\n<li>DOM과 computedStyle을 바탕으로 각 노드의 position과 size를 계산합니다. (layout)</li>\n<li>layout tree를 바탕으로 layer tree를 생성합니다. (comp.assign)</li>\n<li>노드를 어떻게 그릴지에 대한 작업 순서를 정합니다. (paint)</li>\n<li>작업 순서를 compositor thread (=impl) 에게 전달합니다. (commit)</li>\n<li>GPU process에서 paint 단계 때 정한 작업 순서들을 바탕으로 bitmap을 생성합니다. (rasterization)</li>\n<li>이제 bitmap을 OpenGL을 통해 화면에 그립니다.</li>\n</ol>\n<p>그림에 나오는 중간에 prepaint, tiling, SKIA는 아래 쪽에서 추가로 설명하겠습니다.</p>\n<h1>화면에 그려지는 과정</h1>\n<h2>Parsing</h2>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159617-6a28988b-2bc6-434c-b537-f911a3318c63.png\" alt=\"sc_-41\"></p>\n<p>HTMLParser는 HTML tag를 읽으면서 DOM Tree를 생성합니다.</p>\n<p>조금 더 구체적인 parsing 과정은 다음과 같습니다.</p>\n<p><img src=\"https://develoger.kr/wp-content/uploads/parsing-1200x665.webp\"></p>\n<p>from : <a href=\"https://web.dev/critical-rendering-path-constructing-the-object-model/\">https://web.dev/critical-rendering-path-constructing-the-object-model/</a></p>\n<h2>DOM</h2>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159624-f6079a53-0751-4379-b76b-4ce85101b799.png\" alt=\"sc_-43-1\"></p>\n<p>DOM은 두 가지를 의미합니다.</p>\n<ol>\n<li>HTML Tag를 parsing 해서 만든 C++로 이루어진 트리 형태의 자료 구조 (내부 구현체)</li>\n<li>이 내부 구현체에 Javascript로 접근해서 조작할 수 있도록 만든 API</li>\n</ol>\n<h2>Style Calculation</h2>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159629-40f8532e-39fa-4c88-8b84-c5d8e221d165.png\" alt=\"sc_-45-1\"></p>\n<p>CSSParser는 CSS코드를 파싱하면서 StyleRule을 생성하고 그것을 StyleSheetContents에 담습니다.</p>\n<p>다시 말해서,</p>\n<div class=\"gatsby-highlight\" data-language=\"css\"><pre class=\"language-css\"><code class=\"language-css\"><span class=\"token selector\">.fancy-button</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">background</span><span class=\"token punctuation\">:</span> green<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">border</span><span class=\"token punctuation\">:</span> 3px solid red<span class=\"token punctuation\">;</span>\n  <span class=\"token property\">font-size</span><span class=\"token punctuation\">:</span> 1em<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이런 css코드를 파싱해서</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159643-910ba991-5d2b-4c80-891d-2497ab2c3f1e.png\" alt=\"sc_-56\"></p>\n<p>이런 StyleRule을 만들어 내는것이라 <strong>추측</strong>됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159652-7ba1694d-7b2a-4970-97b5-fa675bec2c57.png\" alt=\"sc_-57\"></p>\n<p>StyleResolver는 StyleRule이 담겨있는 StyleSheetContents를 바탕으로 각 노드(Element)에 대한 ComputedStyle을 구해서 적용합니다.</p>\n<p>ComputedStyle은 CSS selector 우선순위까지 다 고려(cascading)해서 최종적으로 노드에 적용될 CSS값들의 모음입니다. dev-tools에서 쉽게 확인 가능합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159666-b660e116-2937-4671-90b2-b60ae29d0fbe.png\" alt=\"sc_-58\"></p>\n<h3>쉽게 말하자면</h3>\n<p>CSS코드를 파싱하고, DOM의 각 노드에 대한 ComputedStyle을 구해서 적용합니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159688-b44bf7c4-12fd-44de-a6c8-61f6e1aa504d.png\" alt=\"sc_-59\"></p>\n<p>from : <a href=\"https://developer.chrome.com/blog/inside-browser-part3/#subresource-loading\">https://developer.chrome.com/blog/inside-browser-part3/#subresource-loading</a></p>\n<h2>Layout</h2>\n<p>이제 DOM을 만들었고 각 노드에 대한 style도 알았으니, 위치와 사이즈 값도 알아낼 수 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159692-d7159e57-7ae2-4661-bf0e-c9872ffb483c.png\" alt=\"sc_-61\"></p>\n<h3>너무 어려운 Layout 과정</h3>\n<p>그런데 이 과정은 꽤나 어렵습니다. 고려해야 할 것이 많기 때문입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159696-0fb835d2-e3db-42e6-9934-a016b6846054.png\" alt=\"sc_-62\"></p>\n<p>이렇게 라인이 넘어가는 것도 고려해주어야하고,</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159703-a9b3992e-188e-4b52-91e2-5026ee2cb1fc.png\" alt=\"sc_-63\"></p>\n<p>font도 고려해주어야 합니다. 이 외에도 overflow나 float속성도 고려해서 위치 값을 계산해야 합니다.</p>\n<p>제가 어디서 읽은 바로는 크롬 브라우저 개발자의 대부분이 이 layout계산쪽에서 일을 한다고 합니다. 그 정도로 복잡하고 어려운 일이라고 합니다.</p>\n<h3>Layout Tree 생성</h3>\n<p>메인 스레드에서 이 레이아웃을 계산하면서 레이아웃 트리를 생성합니다. 레이아웃 트리의 LayoutObject들은 각각 DOM Tree의 노드와 연결되어 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159710-4067506f-3d0e-4fa7-936c-d57abfc0343c.png\" alt=\"sc_-64\"></p>\n<p>우리가 흔히 아는 reflow가 바로 여기서 발생합니다. 즉, reflow는 layout tree를 순회하면서 각 LayoutObject의 위칫값과 사이즈를 다시 계산하는 것을 의미합니다.</p>\n<p>예를 들어서, DOM Element의 width/height/top/right 등을 바꾸면 이 layout tree를 순회하면서 LayoutObject의 위칫값과 사이즈를 다시 계산합니다.</p>\n<h2>Paint</h2>\n<p>이제 각 노드의 스타일과 위칫값을 알았으니, 화면에 그리는 일만 남았습니다. 하지만! 이름과 달리 <strong>paint 단계는 화면에 그리는 일을 하는 단계가 아닙니다.</strong></p>\n<p>paint 단계에서는 화면에 무엇을 어떤 순서로 그려야 할지에 대한 정보를 기록하는 일이 이뤄집니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159724-0acade83-abd2-4736-9260-75f1fc6278a4.png\" alt=\"sc_-65\"></p>\n<p>PO즉, Paint Operation은 ”[100, 200]에 가로가 200px, 세로가 140px인 사각형을 그려!” 라는 작업 내용입니다. 이것들이 쌓여서 DisplayItem에 들어가고, 이 DisplayItem의 목록은 PaintArtifact에 들어갑니다.</p>\n<p>DisplayItem을 조금 더 확대해보면 이렇게 생겼습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159731-7a47a69b-43f2-43a8-9a1e-63d92a3fb279.png\" alt=\"sc_-68-1\"></p>\n<p>위 설명에 대한 조금 더 쉬운 그림은 다음과 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159738-4445cf16-174b-49f7-9bb2-755477dc14b6.png\" alt=\"sc_-66\"></p>\n<p>from : <a href=\"https://developer.chrome.com/blog/inside-browser-part3/#subresource-loading\">https://developer.chrome.com/blog/inside-browser-part3/#subresource-loading</a></p>\n<h3>z-index를 고려하라</h3>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159745-f6fb4b83-1678-49b8-8934-368b128a394f.png\" alt=\"sc_-67-1\"></p>\n<p>z-index도 잘 고려돼서 그려질 수 있도록 PO가 구성됩니다.</p>\n<h2>Raster</h2>\n<p>이제 어떤 순서로 그려야 할지 알았기 때문에, 화면에 그리는 일만 남았다고 생각할 수 있지만, 아직 조금 더 남았습니다.</p>\n<p>위에서 구한 정보들(DisplayItem)을 바탕으로 bitmap을 만드는 일을 rasterization이라고 부릅니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159751-f8a94efd-0235-4f96-99a3-bebe14deb18a.png\" alt=\"sc_-69-2\"></p>\n<p>그리고 이 rasterization은 일반적으로 GPU 안에서 이뤄집니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159756-2fffa8fb-e5fc-4d16-b2ab-23c105a05459.png\" alt=\"sc_-70-2\"></p>\n<p>현재 사용 중인 크롬 브라우저에서 GPU 가속이 사용되고 있는지 확인하려면 <a href=\"chrome://gpu/\">chrome://gpu/</a> 요기로 들어가면 됩니다.</p>\n<img width=\"500px\" alt=\"sc_-71-1\" src=\"https://user-images.githubusercontent.com/52737532/192159765-a776cba5-7661-4276-ba26-8a7e976c56fc.png\">\n<p>Rasterization에 Hardware accelerated가 되어있는 것을 볼 수 있습니다.</p>\n<h3>raster to screen</h3>\n<p>이렇게 rasterization 되고 나서 screen에 pixel로 그려지는 작업도 GPU에서 일어납니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159769-16ab1039-8f26-4a74-a017-5ea9b8c174f7.png\" alt=\"sc_-73-3\"></p>\n<h4>SKIA</h4>\n<p>다양한 하드웨어 및 소프트웨어 플랫폼에서 작동하는 공통 API를 제공하는 오픈 소스 2D 그래픽 라이브러리입니다. 구글 크롬, 크롬 OS, 안드로이드, Flutter 등 여러 제품의 그래픽 엔진 역할을 합니다. 구글에서 만들었습니다.</p>\n<h4>OpenGL</h4>\n<p>그래픽 카드와 통신할 수 있도록 지원해주는 API 또는 표준 규격입니다. 이 API는 GPU에게 직접적으로 명령을 내리는 command로 변환됩니다.</p>\n<h4>Skia와 OpenGL의 관계</h4>\n<p>Skia 라이브러리에서 제공하는 API를 사용하면 OpenGL API로 변환됩니다. 즉, Skia는 조금 더 고수준의 API이죠.</p>\n<h3>쉽게 설명하자면</h3>\n<p>Paint이후 GPU에서 rasterization이 이뤄지고 화면에 pixel로 그려집니다.</p>\n<h1>화면에 그린 이후 변화 발생</h1>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159778-abd58db4-af18-4a45-a2ae-32797246892f.png\" alt=\"sc_-74-4\"></p>\n<p><code class=\"language-text\">DOM -> style -> layout -> paint -> raster -> GPU -> 화면에 그리기!</code> 까지 왔습니다. 그런데 사용자가 스크롤을 하거나, 줌인/아웃을 하거나 Javascript로 style을 동적으로 바꾸면 브라우저는 이를 어떻게 처리할까요?</p>\n<h2>Frame</h2>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159783-3f7b1e50-b1da-4577-affc-aca296cf700c.png\" alt=\"sc_-75-1\"></p>\n<p>초당 60 frame을 그리지 못하면, 화면이 뚝뚝 끊겨 보이는(janky) 현상이 발생합니다.</p>\n<h2>Invalidation</h2>\n<p>렌더링이 빠르게 되도록 하는 여러 방법 중 하나는, 변했는지 변하지 않았는지 체크하고 변한 부분만 업데이트하는 것입니다. 예를 들어서</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159791-5aeaf923-6a91-4977-add0-db92f7c03774.png\" alt=\"sc_-77-1\"></p>\n<p>DOM노드의 style에 변화가 가해졌으니 다음 프레임때 computedStyle을 다시 구할 필요가 있기 때문에, 표시(mark)해 놓습니다.(SetNeedsStyleRecalc 호출)</p>\n<p>마찬가지로 Layout에 변화가 가해졌다면, 다음 프래임 때 layout을 다시 계산하도록 표시해 놓습니다(SetNeedsLayout).</p>\n<p>변화가 없다면 이전 프레임에서 계산된 결과(DOM Node, LayoutObject 등)를 그대로 사용합니다.</p>\n<p>이렇게 변화가 가해졌을 때 다음 프레임에 새로 계산하도록 표시하는 것을 invalidation이라고 부릅니다. (slide에는 granular asynchronous invalidations 라고 적혀있습니다)</p>\n<h2>repaint</h2>\n<p>하지만 스크롤이나 애니메이션 같은 경우에는 위의 optimization이 큰 효과를 못봅니다. 너무 많이 변하기 때문입니다. 예를 들어서, 스크롤 같은 경우</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159797-74e9f573-0815-462b-9886-bc3a481c6bad.png\" alt=\"sc_-79-1\"></p>\n<p>매 스크롤 이벤트마다 repaint와 rasterization이 계속 발생합니다. 이는 비용이 많이 들어갑니다.</p>\n<h2>jank</h2>\n<p>scroll으로 인한 repaint - rasterization 외에도 우리가 신경 써야할 것이 있습니다. 바로 Javascript도 main thread에서 실행된다는 것입니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159803-a1c5c147-8952-40a7-8d3a-8fcafe487d0f.png\" alt=\"sc_-80-2\"></p>\n<p>(<code class=\"language-text\">scroll로 인한 repaint - rasterization은 어쩔 수 없는 것인데 왜 신경 써야 하나?..</code>라고 생각하실 수 있습니다. 이는 아래 compositor쪽에 이야기가 다시 나옵니다.)</p>\n<p>그래서 아무리 rendering pipeline이 빠르게 진행된다고 하더라도 javascript 코드 실행이 너무 오래 걸리면 jank가 발생합니다.</p>\n<h1>Compositing</h1>\n<p>그래서 invalidation 같은 최적화 기능도 있지만, scroll로 인한 repaint + rasterization과 Javascript 코드를 실행하는 비용이 많이 들어서 rendering이 늦어지는 문제를 완화하기 위해 compositing이 나왔습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159812-5b0227c9-05e3-4e4e-aeca-aeea90847762.png\" alt=\"sc_-82-1\"></p>\n<p>먼저 메인 스레드에서 page를 여러 layer로 나누고 compositor thread에서 이를 합성합니다. 이렇게 layer를 나누면 rasterizing이 각 layer에서 독립적으로 발생합니다.</p>\n<h2>예시</h2>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159816-91c23a2b-24f3-4197-b21b-10f3d924f933.gif\" alt=\"comisiting-layer-1\"></p>\n<p>BBB layer를 rasterizing해서 만든 <strong>bitmap만 transform하면</strong>, 매 animation frame마다 전체 페이지를 rasterizing 하지 않아도 됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159824-2717ecff-ba3f-45ad-a0c9-5222808462c9.gif\" alt=\"compositing-layer-3\"></p>\n<p>그리고 부모가 layer라면 자식들도 그 layer의 subtree가 됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159828-c3a30b98-63fb-4a77-9519-c6ff9087ec78.gif\" alt=\"compositing-layer-4\"></p>\n<p>이렇게 layer를 분리해서 rasterizing 후 <strong>생성된 bitmap만 변형</strong>하게 된다면, 매 animation frame 마다 전체 페이지를 rasterizing 하지 않아도 되기 때문에 효율적입니다.</p>\n<h2>threaded input</h2>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159834-9e3fd36d-b926-4f73-aa13-1a679b880bb5.png\" alt=\"sc_-86\"></p>\n<p>main thread가 바쁠 때 compositor thread는 browser process로부터 사용자의 스크롤 입력을 받아 bitmap을 transform 합니다.</p>\n<p>물론 사용자가 특정 레이어가 아닌 전체 페이지를 스크롤링하면 compositor thread에서 처리하지 않고 main thread로 일을 넘깁니다. 왜냐하면 전체 페이지를 다시 그리는 render pipeline을 거쳐야 하기 때문입니다.</p>\n<p>추가로 Javascript에서 scroll event listener를 걸어놓은 경우에는 사용자 입력을 main thread에서 처리하도록 task queue에 넣습니다.</p>\n<h2>Layer는 어떻게 만들어지는가?</h2>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159838-38d3765d-3783-40b9-b8d0-6d12e174deef.png\" alt=\"sc_-87-1\"></p>\n<p>Layer는 <strong>transform</strong>같은 CSS property를 바탕으로 <strong>layout object</strong>에서 생성됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159845-1b039a75-4e4c-4d43-b213-83a18f7ea0c7.png\" alt=\"sc_-88-1\"></p>\n<p><strong>main thread</strong>에서 DOM -> style -> layout 이후에 layer가 만들어지고, 이 단계를 compositing assignments라고 부릅니다.</p>\n<p>그리고 paint 단계에서 각 레이어는 자신만의 DisplayItemList를 가지게 됩니다. 즉 “무엇을 어떤 순서로 그릴 것인지”에 대한 정보인 DisplayItemList가 레이어마다 따로따로 설정된다는 의미입니다.</p>\n<h2>pre-paint</h2>\n<p>paint전에 pre-paint 단계가 있습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159850-77d00327-0f74-490a-a16d-4880c6fd6e44.png\" alt=\"sc_-90\"></p>\n<p>이 단계에서 property tree를 생성합니다. 참고로 property tree는 아래처럼 생겼습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159854-8e47bf6d-bb72-4fc5-b1a1-342ef656eabe.png\" alt=\"sc_-89\"></p>\n<p>Property tree에 대하여 (<a href=\"https://d2.naver.com/helloworld/5237120\">Naver D2 글</a>)</p>\n<p>“레이아웃 트리와 다음에 설명할 페인트 트리 사이에 한 가지 작업이 더 있다. 레이아웃 트리를 순회하면서 속성 트리(property tree)를 만드는 작업이다. 속성 트리는 <code class=\"language-text\">clip</code>, <code class=\"language-text\">transform</code>, <code class=\"language-text\">opacity</code> 등의 속성 정보만 가진 트리이다. 기존에는 이런 정보를 분리하지 않고 노드마다 가지고 있었다. 그래서 특정 노드의 속성이 변경되면 해당 노드의 하위 노드에도 이 값을 다시 반영하면서 노드를 순회해야 했다. 최신 Chrome에서는 이런 속성만 별도로 관리하고 각 노드에서는 속성 트리의 노드를 참조하는 방식으로 변경되고 있다.”</p>\n<h2>Commit</h2>\n<p>paint가 완료되면, 이제 이렇게 만든 레이어들을 <strong>하나의 프레임으로 만들기 위해</strong>서 레이어들과 property tree를 compositor thread에게 <strong>넘겨</strong>줘야 합니다. 이 단계를 commit이라 부릅니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159861-e42fd175-4cad-4cd8-a142-9f2b69a4da51.png\" alt=\"sc_-91\"></p>\n<h2>tiling</h2>\n<p>paint 이후에 layer의 paint operation을 bitmap으로 만드는 작업인 rasterization을 합니다. 그런데 layer가 너무 큰 경우는 어떨까요?</p>\n<p>사용자에게 보이는 view port보다 엄~청 큰 layer의 경우, 이 layer를 rasterizing 하는 것은 너무 비용이 큽니다. 그래서 compositor thread에서 이 layer는 작은 tile 들로 나눠집니다. 이 tile 들은 render process 안에 있는 <strong>여러 raster thread에서 비동기적</strong>으로 rasterzied 됩니다.</p>\n<p>그런데 아래쪽에서는 rasterization은 <strong>Skia를 통해 GPU</strong>에서 일어난다고 하는데, <strong>아마도</strong> render process의 raster thread가 GPU Process의 SKIA를 사용해서 rasterization 한다는 의미 같습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159871-5d10b544-916c-4509-98c3-8a02ab7feead.png\" alt=\"sc_-93\"></p>\n<h2>Layer 그리기</h2>\n<p>layer의 모든 tile 들이 rasterizing되면 compositor thread는 각 tile에 대한 DrawQuad를 생성합니다. DrawQuad는 tile을 rasterizing 한 bitmap을 참조하고 있고, tile을 스크린의 어느 위치에 그려야 하는지에 대한 instruction를 가지고 있습니다. 이때 이 위칫값은 property tree를 고려해서 계산됩니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159877-43cc497e-8a58-46ee-a634-2615709593f7.png\" alt=\"sc_-94\"></p>\n<p>이렇게 만든 DrawQuad를 묶어서 CompositorFrame 객체에 넣습니다. 그리고 이 CompositorFrame은 GPU Process에게 넘겨집니다.</p>\n<p>지금까지 우리는 renderer process 안에서 main thread + compositor thread + raster thread를 활용해 DOM -> style -> layout -> layer -> pre-paint -> paint -> commit -> tiling 과정을 통해 최종적으로 CompositorFrame을 만들었습니다.</p>\n<p>남은 일은 이 CompositorFrame(=<strong>animation frame</strong>)을 화면에 그리기만 하면 됩니다.</p>\n<h1>Display(viz)</h1>\n<p>GPU Process는 CompositorFrame을 받아서 SKIA API를 사용해 OpenGL(혹은 Vulkan) API를 부르고, OpenGL은 그래픽카드를 사용해 화면에 tile을 그립니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159884-9ea11ff9-43d8-4056-89ce-54e7825e91a6.png\" alt=\"sc_-96-1\"></p>\n<h1>정리</h1>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159893-65f720b8-e309-4dc9-ab92-10d4a10fe1a6.png\" alt=\"sc_-98\"></p>\n<ol>\n<li>브라우저는 web content를 받습니다.</li>\n<li>DOM Tree를 만듭니다.</li>\n<li>style을 계산합니다(resolve styles).</li>\n<li>layout을 계산합니다.</li>\n<li>layer를 만듭니다.</li>\n<li>property tree를 만듭니다.</li>\n<li>layer를 paint합니다.</li>\n<li>layer + DisplayItemList(paint operations) + property tree를 compositor thread로 commit(복사/붙여넣기)합니다.</li>\n<li>layer를 여러 작은 조각(tile)로 나눕니다.</li>\n<li>SKIA library를 사용해 tile을 rasterizing 합니다.</li>\n<li>DrawQuads를 생성합니다.</li>\n<li>Skia와 OpenGL를 통해 DrawQuads를 실제 스크린에 그립니다. (pixel화)</li>\n</ol>\n<h1>질문</h1>\n<h2>external CSS도 HTML parser를 block 하나요?</h2>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159900-c5529510-10a4-4262-b8dc-dee03fce5353.png\" alt=\"sc_-48\"></p>\n<p>from : <a href=\"https://web.dev/preload-scanner\">https://web.dev/preload-scanner</a></p>\n<p>네, blocking 합니다. <a href=\"https://web.dev/preload-scanner/#whats-a-preload-scanner\">관련글</a></p>\n<p>I<em>n this case, the parser runs into a</em> <code class=\"language-text\">&lt;link></code> <em>element for an external CSS file, which blocks the browser from parsing the rest of the document—or even rendering any of it—until the CSS is downloaded and parsed.</em></p>\n<h2>inline style 도 parser를 block 하나요?</h2>\n<p>네 block합니다! <a href=\"https://web.dev/render-blocking-resources/#how-to-eliminate-render-blocking-stylesheets\">관련 글</a></p>\n<p>Similar to inlining code in a <code class=\"language-text\">&lt;script></code> tag, <strong>inline critical styles</strong> required for the first paint inside a <code class=\"language-text\">&lt;style></code> <strong>block</strong> at the <code class=\"language-text\">head</code> of the HTML page</p>\n<h2>style자원을 가져오고 parsing할때까지 왜 HTML Parser는 멈춰있나요?</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/Flash_of_unstyled_content\">flash of unstyled content (FOUC)</a> 문제 때문에 그렇습니다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/52737532/192159908-8716f000-ce91-46e6-815e-b77abe7257b3.png\" alt=\"sc_-49\"></p>\n<p>from : <strong><a href=\"https://web.dev/preload-scanner\">https://web.dev/preload-scanner</a></strong></p>\n<p>그러니까, style.css파일을 다운받고 있는데, HTML Parser가 다 파싱하고 rendering까지 끝나면 스타일이 적용되지 않은 사이트가 사용자에게 보일것이고, 후에 style.css파일 다운로드가 끝나고 파싱하고 적용하면 그때 스타일이 적용된 사이트가 보일것입니다.</p>\n<p>이는 사용자에게 <strong>번쩍</strong>! 하는 느낌을 주기 때문에 별로 좋지 않습니다. 그래서 style.css파일을 다운받고 파싱이 끝날때까지 HTML Parser는 기다립니다.</p>\n<h1>참고</h1>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=-P28LKWTzrI\">CPU vs GPU</a></li>\n<li><a href=\"https://ibocon.tistory.com/242\">브라우저 렌더링 Browser rendering</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/5237120\">최신 브라우저의 내부 살펴보기 3 - 렌더러 프로세스의 내부 동작 (Naver D2)</a></li>\n<li><a href=\"https://developer.chrome.com/blog/inside-browser-part3/\">Inside look at modern web browser (part 3)</a></li>\n<li><a href=\"https://alistapart.com/article/braces-to-pixels/\">Braces to Pixels</a></li>\n<li><a href=\"https://web.dev/preload-scanner/#whats-a-preload-scanner\">Don’t fight the browser preload scanner</a></li>\n</ul>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이 글은 Google Chrome 개발자 Steve Kobes의 "},{"type":"element","tagName":"a","properties":{"href":"https://www.youtube.com/watch?v=K2QHdgAKP-s"},"children":[{"type":"text","value":"Life of Pixel영상"}]},{"type":"text","value":"을 보고 정리한 내용입니다. 사용된 이미지들은 "},{"type":"element","tagName":"a","properties":{"href":"https://user-images.githubusercontent.com/52737532/195376209-a2eed93c-dbd1-4880-b051-bf33cd869cdf.png","target":"_blank"},"children":[{"type":"text","value":"Steve Kobes의 허락"}]},{"type":"text","value":"\n하에 "},{"type":"element","tagName":"a","properties":{"href":"https://docs.google.com/presentation/d/1boPxbgNrTU0ddsc144rcXayGA_WF53k96imRH8Mp34Y/edit#slide=id.ga884fe665f_64_6"},"children":[{"type":"text","value":"slide show"}]},{"type":"text","value":"에서 가져왔습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"이 글의 목표"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"어떤 과정을 통해 HTML파일이 화면에 그려지고, page가 되는지 이해합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"composite에 대해 이해합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"왜 layer를 분리하는것이 더 빠른 렌더링을 가능하게 하는지 이해합니다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"간단 요약"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159612-0e7e1ae1-245e-4c9d-92ae-bef108f81aa2.png","alt":"sc_-36"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"HTML content(index.html)를 불러옵니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"HTML Parser가 index.html을 parsing 하면서 DOM을 생성합니다. (DOM)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"style 자원을 만나면 CSS Parser가 parsing 후, 각 DOM 노드에 computedStyle을 적용합니다. (style)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"DOM과 computedStyle을 바탕으로 각 노드의 position과 size를 계산합니다. (layout)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"layout tree를 바탕으로 layer tree를 생성합니다. (comp.assign)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"노드를 어떻게 그릴지에 대한 작업 순서를 정합니다. (paint)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"작업 순서를 compositor thread (=impl) 에게 전달합니다. (commit)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"GPU process에서 paint 단계 때 정한 작업 순서들을 바탕으로 bitmap을 생성합니다. (rasterization)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"이제 bitmap을 OpenGL을 통해 화면에 그립니다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그림에 나오는 중간에 prepaint, tiling, SKIA는 아래 쪽에서 추가로 설명하겠습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"화면에 그려지는 과정"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Parsing"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159617-6a28988b-2bc6-434c-b537-f911a3318c63.png","alt":"sc_-41"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"HTMLParser는 HTML tag를 읽으면서 DOM Tree를 생성합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"조금 더 구체적인 parsing 과정은 다음과 같습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://develoger.kr/wp-content/uploads/parsing-1200x665.webp"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"from : "},{"type":"element","tagName":"a","properties":{"href":"https://web.dev/critical-rendering-path-constructing-the-object-model/"},"children":[{"type":"text","value":"https://web.dev/critical-rendering-path-constructing-the-object-model/"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"DOM"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159624-f6079a53-0751-4379-b76b-4ce85101b799.png","alt":"sc_-43-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"DOM은 두 가지를 의미합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"HTML Tag를 parsing 해서 만든 C++로 이루어진 트리 형태의 자료 구조 (내부 구현체)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"이 내부 구현체에 Javascript로 접근해서 조작할 수 있도록 만든 API"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Style Calculation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159629-40f8532e-39fa-4c88-8b84-c5d8e221d165.png","alt":"sc_-45-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CSSParser는 CSS코드를 파싱하면서 StyleRule을 생성하고 그것을 StyleSheetContents에 담습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"다시 말해서,"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"css"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-css"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-css"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","selector"]},"children":[{"type":"text","value":".fancy-button"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"background"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" green"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"border"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" 3px solid red"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","property"]},"children":[{"type":"text","value":"font-size"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" 1em"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이런 css코드를 파싱해서"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159643-910ba991-5d2b-4c80-891d-2497ab2c3f1e.png","alt":"sc_-56"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이런 StyleRule을 만들어 내는것이라 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"추측"}]},{"type":"text","value":"됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159652-7ba1694d-7b2a-4970-97b5-fa675bec2c57.png","alt":"sc_-57"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"StyleResolver는 StyleRule이 담겨있는 StyleSheetContents를 바탕으로 각 노드(Element)에 대한 ComputedStyle을 구해서 적용합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"ComputedStyle은 CSS selector 우선순위까지 다 고려(cascading)해서 최종적으로 노드에 적용될 CSS값들의 모음입니다. dev-tools에서 쉽게 확인 가능합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159666-b660e116-2937-4671-90b2-b60ae29d0fbe.png","alt":"sc_-58"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"쉽게 말하자면"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"CSS코드를 파싱하고, DOM의 각 노드에 대한 ComputedStyle을 구해서 적용합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159688-b44bf7c4-12fd-44de-a6c8-61f6e1aa504d.png","alt":"sc_-59"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"from : "},{"type":"element","tagName":"a","properties":{"href":"https://developer.chrome.com/blog/inside-browser-part3/#subresource-loading"},"children":[{"type":"text","value":"https://developer.chrome.com/blog/inside-browser-part3/#subresource-loading"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Layout"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이제 DOM을 만들었고 각 노드에 대한 style도 알았으니, 위치와 사이즈 값도 알아낼 수 있습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159692-d7159e57-7ae2-4661-bf0e-c9872ffb483c.png","alt":"sc_-61"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"너무 어려운 Layout 과정"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그런데 이 과정은 꽤나 어렵습니다. 고려해야 할 것이 많기 때문입니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159696-0fb835d2-e3db-42e6-9934-a016b6846054.png","alt":"sc_-62"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 라인이 넘어가는 것도 고려해주어야하고,"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159703-a9b3992e-188e-4b52-91e2-5026ee2cb1fc.png","alt":"sc_-63"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"font도 고려해주어야 합니다. 이 외에도 overflow나 float속성도 고려해서 위치 값을 계산해야 합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"제가 어디서 읽은 바로는 크롬 브라우저 개발자의 대부분이 이 layout계산쪽에서 일을 한다고 합니다. 그 정도로 복잡하고 어려운 일이라고 합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"Layout Tree 생성"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"메인 스레드에서 이 레이아웃을 계산하면서 레이아웃 트리를 생성합니다. 레이아웃 트리의 LayoutObject들은 각각 DOM Tree의 노드와 연결되어 있습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159710-4067506f-3d0e-4fa7-936c-d57abfc0343c.png","alt":"sc_-64"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"우리가 흔히 아는 reflow가 바로 여기서 발생합니다. 즉, reflow는 layout tree를 순회하면서 각 LayoutObject의 위칫값과 사이즈를 다시 계산하는 것을 의미합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"예를 들어서, DOM Element의 width/height/top/right 등을 바꾸면 이 layout tree를 순회하면서 LayoutObject의 위칫값과 사이즈를 다시 계산합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Paint"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이제 각 노드의 스타일과 위칫값을 알았으니, 화면에 그리는 일만 남았습니다. 하지만! 이름과 달리 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"paint 단계는 화면에 그리는 일을 하는 단계가 아닙니다."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"paint 단계에서는 화면에 무엇을 어떤 순서로 그려야 할지에 대한 정보를 기록하는 일이 이뤄집니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159724-0acade83-abd2-4736-9260-75f1fc6278a4.png","alt":"sc_-65"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"PO즉, Paint Operation은 ”[100, 200]에 가로가 200px, 세로가 140px인 사각형을 그려!” 라는 작업 내용입니다. 이것들이 쌓여서 DisplayItem에 들어가고, 이 DisplayItem의 목록은 PaintArtifact에 들어갑니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"DisplayItem을 조금 더 확대해보면 이렇게 생겼습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159731-7a47a69b-43f2-43a8-9a1e-63d92a3fb279.png","alt":"sc_-68-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"위 설명에 대한 조금 더 쉬운 그림은 다음과 같습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159738-4445cf16-174b-49f7-9bb2-755477dc14b6.png","alt":"sc_-66"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"from : "},{"type":"element","tagName":"a","properties":{"href":"https://developer.chrome.com/blog/inside-browser-part3/#subresource-loading"},"children":[{"type":"text","value":"https://developer.chrome.com/blog/inside-browser-part3/#subresource-loading"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"z-index를 고려하라"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159745-f6fb4b83-1678-49b8-8934-368b128a394f.png","alt":"sc_-67-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"z-index도 잘 고려돼서 그려질 수 있도록 PO가 구성됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Raster"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이제 어떤 순서로 그려야 할지 알았기 때문에, 화면에 그리는 일만 남았다고 생각할 수 있지만, 아직 조금 더 남았습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"위에서 구한 정보들(DisplayItem)을 바탕으로 bitmap을 만드는 일을 rasterization이라고 부릅니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159751-f8a94efd-0235-4f96-99a3-bebe14deb18a.png","alt":"sc_-69-2"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그리고 이 rasterization은 일반적으로 GPU 안에서 이뤄집니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159756-2fffa8fb-e5fc-4d16-b2ab-23c105a05459.png","alt":"sc_-70-2"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"현재 사용 중인 크롬 브라우저에서 GPU 가속이 사용되고 있는지 확인하려면 "},{"type":"element","tagName":"a","properties":{"href":"chrome://gpu/"},"children":[{"type":"text","value":"chrome://gpu/"}]},{"type":"text","value":" 요기로 들어가면 됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"width":"500px","alt":"sc_-71-1","src":"https://user-images.githubusercontent.com/52737532/192159765-a776cba5-7661-4276-ba26-8a7e976c56fc.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Rasterization에 Hardware accelerated가 되어있는 것을 볼 수 있습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"raster to screen"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 rasterization 되고 나서 screen에 pixel로 그려지는 작업도 GPU에서 일어납니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159769-16ab1039-8f26-4a74-a017-5ea9b8c174f7.png","alt":"sc_-73-3"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"SKIA"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"다양한 하드웨어 및 소프트웨어 플랫폼에서 작동하는 공통 API를 제공하는 오픈 소스 2D 그래픽 라이브러리입니다. 구글 크롬, 크롬 OS, 안드로이드, Flutter 등 여러 제품의 그래픽 엔진 역할을 합니다. 구글에서 만들었습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"OpenGL"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그래픽 카드와 통신할 수 있도록 지원해주는 API 또는 표준 규격입니다. 이 API는 GPU에게 직접적으로 명령을 내리는 command로 변환됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Skia와 OpenGL의 관계"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Skia 라이브러리에서 제공하는 API를 사용하면 OpenGL API로 변환됩니다. 즉, Skia는 조금 더 고수준의 API이죠."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"쉽게 설명하자면"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Paint이후 GPU에서 rasterization이 이뤄지고 화면에 pixel로 그려집니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"화면에 그린 이후 변화 발생"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159778-abd58db4-af18-4a45-a2ae-32797246892f.png","alt":"sc_-74-4"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"DOM -> style -> layout -> paint -> raster -> GPU -> 화면에 그리기!"}]},{"type":"text","value":" 까지 왔습니다. 그런데 사용자가 스크롤을 하거나, 줌인/아웃을 하거나 Javascript로 style을 동적으로 바꾸면 브라우저는 이를 어떻게 처리할까요?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Frame"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159783-3f7b1e50-b1da-4577-affc-aca296cf700c.png","alt":"sc_-75-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"초당 60 frame을 그리지 못하면, 화면이 뚝뚝 끊겨 보이는(janky) 현상이 발생합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Invalidation"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"렌더링이 빠르게 되도록 하는 여러 방법 중 하나는, 변했는지 변하지 않았는지 체크하고 변한 부분만 업데이트하는 것입니다. 예를 들어서"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159791-5aeaf923-6a91-4977-add0-db92f7c03774.png","alt":"sc_-77-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"DOM노드의 style에 변화가 가해졌으니 다음 프레임때 computedStyle을 다시 구할 필요가 있기 때문에, 표시(mark)해 놓습니다.(SetNeedsStyleRecalc 호출)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"마찬가지로 Layout에 변화가 가해졌다면, 다음 프래임 때 layout을 다시 계산하도록 표시해 놓습니다(SetNeedsLayout)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"변화가 없다면 이전 프레임에서 계산된 결과(DOM Node, LayoutObject 등)를 그대로 사용합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 변화가 가해졌을 때 다음 프레임에 새로 계산하도록 표시하는 것을 invalidation이라고 부릅니다. (slide에는 granular asynchronous invalidations 라고 적혀있습니다)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"repaint"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"하지만 스크롤이나 애니메이션 같은 경우에는 위의 optimization이 큰 효과를 못봅니다. 너무 많이 변하기 때문입니다. 예를 들어서, 스크롤 같은 경우"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159797-74e9f573-0815-462b-9886-bc3a481c6bad.png","alt":"sc_-79-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"매 스크롤 이벤트마다 repaint와 rasterization이 계속 발생합니다. 이는 비용이 많이 들어갑니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"jank"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"scroll으로 인한 repaint - rasterization 외에도 우리가 신경 써야할 것이 있습니다. 바로 Javascript도 main thread에서 실행된다는 것입니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159803-a1c5c147-8952-40a7-8d3a-8fcafe487d0f.png","alt":"sc_-80-2"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"("},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"scroll로 인한 repaint - rasterization은 어쩔 수 없는 것인데 왜 신경 써야 하나?.."}]},{"type":"text","value":"라고 생각하실 수 있습니다. 이는 아래 compositor쪽에 이야기가 다시 나옵니다.)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그래서 아무리 rendering pipeline이 빠르게 진행된다고 하더라도 javascript 코드 실행이 너무 오래 걸리면 jank가 발생합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Compositing"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그래서 invalidation 같은 최적화 기능도 있지만, scroll로 인한 repaint + rasterization과 Javascript 코드를 실행하는 비용이 많이 들어서 rendering이 늦어지는 문제를 완화하기 위해 compositing이 나왔습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159812-5b0227c9-05e3-4e4e-aeca-aeea90847762.png","alt":"sc_-82-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"먼저 메인 스레드에서 page를 여러 layer로 나누고 compositor thread에서 이를 합성합니다. 이렇게 layer를 나누면 rasterizing이 각 layer에서 독립적으로 발생합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"예시"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159816-91c23a2b-24f3-4197-b21b-10f3d924f933.gif","alt":"comisiting-layer-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"BBB layer를 rasterizing해서 만든 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"bitmap만 transform하면"}]},{"type":"text","value":", 매 animation frame마다 전체 페이지를 rasterizing 하지 않아도 됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159824-2717ecff-ba3f-45ad-a0c9-5222808462c9.gif","alt":"compositing-layer-3"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그리고 부모가 layer라면 자식들도 그 layer의 subtree가 됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159828-c3a30b98-63fb-4a77-9519-c6ff9087ec78.gif","alt":"compositing-layer-4"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 layer를 분리해서 rasterizing 후 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"생성된 bitmap만 변형"}]},{"type":"text","value":"하게 된다면, 매 animation frame 마다 전체 페이지를 rasterizing 하지 않아도 되기 때문에 효율적입니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"threaded input"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159834-9e3fd36d-b926-4f73-aa13-1a679b880bb5.png","alt":"sc_-86"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"main thread가 바쁠 때 compositor thread는 browser process로부터 사용자의 스크롤 입력을 받아 bitmap을 transform 합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"물론 사용자가 특정 레이어가 아닌 전체 페이지를 스크롤링하면 compositor thread에서 처리하지 않고 main thread로 일을 넘깁니다. 왜냐하면 전체 페이지를 다시 그리는 render pipeline을 거쳐야 하기 때문입니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"추가로 Javascript에서 scroll event listener를 걸어놓은 경우에는 사용자 입력을 main thread에서 처리하도록 task queue에 넣습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Layer는 어떻게 만들어지는가?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159838-38d3765d-3783-40b9-b8d0-6d12e174deef.png","alt":"sc_-87-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Layer는 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"transform"}]},{"type":"text","value":"같은 CSS property를 바탕으로 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"layout object"}]},{"type":"text","value":"에서 생성됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159845-1b039a75-4e4c-4d43-b213-83a18f7ea0c7.png","alt":"sc_-88-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"main thread"}]},{"type":"text","value":"에서 DOM -> style -> layout 이후에 layer가 만들어지고, 이 단계를 compositing assignments라고 부릅니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그리고 paint 단계에서 각 레이어는 자신만의 DisplayItemList를 가지게 됩니다. 즉 “무엇을 어떤 순서로 그릴 것인지”에 대한 정보인 DisplayItemList가 레이어마다 따로따로 설정된다는 의미입니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"pre-paint"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"paint전에 pre-paint 단계가 있습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159850-77d00327-0f74-490a-a16d-4880c6fd6e44.png","alt":"sc_-90"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이 단계에서 property tree를 생성합니다. 참고로 property tree는 아래처럼 생겼습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159854-8e47bf6d-bb72-4fc5-b1a1-342ef656eabe.png","alt":"sc_-89"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Property tree에 대하여 ("},{"type":"element","tagName":"a","properties":{"href":"https://d2.naver.com/helloworld/5237120"},"children":[{"type":"text","value":"Naver D2 글"}]},{"type":"text","value":")"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"“레이아웃 트리와 다음에 설명할 페인트 트리 사이에 한 가지 작업이 더 있다. 레이아웃 트리를 순회하면서 속성 트리(property tree)를 만드는 작업이다. 속성 트리는 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"clip"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"transform"}]},{"type":"text","value":", "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"opacity"}]},{"type":"text","value":" 등의 속성 정보만 가진 트리이다. 기존에는 이런 정보를 분리하지 않고 노드마다 가지고 있었다. 그래서 특정 노드의 속성이 변경되면 해당 노드의 하위 노드에도 이 값을 다시 반영하면서 노드를 순회해야 했다. 최신 Chrome에서는 이런 속성만 별도로 관리하고 각 노드에서는 속성 트리의 노드를 참조하는 방식으로 변경되고 있다.”"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Commit"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"paint가 완료되면, 이제 이렇게 만든 레이어들을 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"하나의 프레임으로 만들기 위해"}]},{"type":"text","value":"서 레이어들과 property tree를 compositor thread에게 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"넘겨"}]},{"type":"text","value":"줘야 합니다. 이 단계를 commit이라 부릅니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159861-e42fd175-4cad-4cd8-a142-9f2b69a4da51.png","alt":"sc_-91"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"tiling"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"paint 이후에 layer의 paint operation을 bitmap으로 만드는 작업인 rasterization을 합니다. 그런데 layer가 너무 큰 경우는 어떨까요?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"사용자에게 보이는 view port보다 엄~청 큰 layer의 경우, 이 layer를 rasterizing 하는 것은 너무 비용이 큽니다. 그래서 compositor thread에서 이 layer는 작은 tile 들로 나눠집니다. 이 tile 들은 render process 안에 있는 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"여러 raster thread에서 비동기적"}]},{"type":"text","value":"으로 rasterzied 됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그런데 아래쪽에서는 rasterization은 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Skia를 통해 GPU"}]},{"type":"text","value":"에서 일어난다고 하는데, "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"아마도"}]},{"type":"text","value":" render process의 raster thread가 GPU Process의 SKIA를 사용해서 rasterization 한다는 의미 같습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159871-5d10b544-916c-4509-98c3-8a02ab7feead.png","alt":"sc_-93"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Layer 그리기"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"layer의 모든 tile 들이 rasterizing되면 compositor thread는 각 tile에 대한 DrawQuad를 생성합니다. DrawQuad는 tile을 rasterizing 한 bitmap을 참조하고 있고, tile을 스크린의 어느 위치에 그려야 하는지에 대한 instruction를 가지고 있습니다. 이때 이 위칫값은 property tree를 고려해서 계산됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159877-43cc497e-8a58-46ee-a634-2615709593f7.png","alt":"sc_-94"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 만든 DrawQuad를 묶어서 CompositorFrame 객체에 넣습니다. 그리고 이 CompositorFrame은 GPU Process에게 넘겨집니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"지금까지 우리는 renderer process 안에서 main thread + compositor thread + raster thread를 활용해 DOM -> style -> layout -> layer -> pre-paint -> paint -> commit -> tiling 과정을 통해 최종적으로 CompositorFrame을 만들었습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"남은 일은 이 CompositorFrame(="},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"animation frame"}]},{"type":"text","value":")을 화면에 그리기만 하면 됩니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"Display(viz)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"GPU Process는 CompositorFrame을 받아서 SKIA API를 사용해 OpenGL(혹은 Vulkan) API를 부르고, OpenGL은 그래픽카드를 사용해 화면에 tile을 그립니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159884-9ea11ff9-43d8-4056-89ce-54e7825e91a6.png","alt":"sc_-96-1"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"정리"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159893-65f720b8-e309-4dc9-ab92-10d4a10fe1a6.png","alt":"sc_-98"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"브라우저는 web content를 받습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"DOM Tree를 만듭니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"style을 계산합니다(resolve styles)."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"layout을 계산합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"layer를 만듭니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"property tree를 만듭니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"layer를 paint합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"layer + DisplayItemList(paint operations) + property tree를 compositor thread로 commit(복사/붙여넣기)합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"layer를 여러 작은 조각(tile)로 나눕니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"SKIA library를 사용해 tile을 rasterizing 합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"DrawQuads를 생성합니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Skia와 OpenGL를 통해 DrawQuads를 실제 스크린에 그립니다. (pixel화)"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"질문"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"external CSS도 HTML parser를 block 하나요?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159900-c5529510-10a4-4262-b8dc-dee03fce5353.png","alt":"sc_-48"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"from : "},{"type":"element","tagName":"a","properties":{"href":"https://web.dev/preload-scanner"},"children":[{"type":"text","value":"https://web.dev/preload-scanner"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"네, blocking 합니다. "},{"type":"element","tagName":"a","properties":{"href":"https://web.dev/preload-scanner/#whats-a-preload-scanner"},"children":[{"type":"text","value":"관련글"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"I"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"n this case, the parser runs into a"}]},{"type":"text","value":" "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<link>"}]},{"type":"text","value":" "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"element for an external CSS file, which blocks the browser from parsing the rest of the document—or even rendering any of it—until the CSS is downloaded and parsed."}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"inline style 도 parser를 block 하나요?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"네 block합니다! "},{"type":"element","tagName":"a","properties":{"href":"https://web.dev/render-blocking-resources/#how-to-eliminate-render-blocking-stylesheets"},"children":[{"type":"text","value":"관련 글"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Similar to inlining code in a "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<script>"}]},{"type":"text","value":" tag, "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"inline critical styles"}]},{"type":"text","value":" required for the first paint inside a "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"<style>"}]},{"type":"text","value":" "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"block"}]},{"type":"text","value":" at the "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"head"}]},{"type":"text","value":" of the HTML page"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"style자원을 가져오고 parsing할때까지 왜 HTML Parser는 멈춰있나요?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://en.wikipedia.org/wiki/Flash_of_unstyled_content"},"children":[{"type":"text","value":"flash of unstyled content (FOUC)"}]},{"type":"text","value":" 문제 때문에 그렇습니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/52737532/192159908-8716f000-ce91-46e6-815e-b77abe7257b3.png","alt":"sc_-49"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"from : "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://web.dev/preload-scanner"},"children":[{"type":"text","value":"https://web.dev/preload-scanner"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그러니까, style.css파일을 다운받고 있는데, HTML Parser가 다 파싱하고 rendering까지 끝나면 스타일이 적용되지 않은 사이트가 사용자에게 보일것이고, 후에 style.css파일 다운로드가 끝나고 파싱하고 적용하면 그때 스타일이 적용된 사이트가 보일것입니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이는 사용자에게 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"번쩍"}]},{"type":"text","value":"! 하는 느낌을 주기 때문에 별로 좋지 않습니다. 그래서 style.css파일을 다운받고 파싱이 끝날때까지 HTML Parser는 기다립니다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h1","properties":{},"children":[{"type":"text","value":"참고"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://www.youtube.com/watch?v=-P28LKWTzrI"},"children":[{"type":"text","value":"CPU vs GPU"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://ibocon.tistory.com/242"},"children":[{"type":"text","value":"브라우저 렌더링 Browser rendering"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://d2.naver.com/helloworld/5237120"},"children":[{"type":"text","value":"최신 브라우저의 내부 살펴보기 3 - 렌더러 프로세스의 내부 동작 (Naver D2)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://developer.chrome.com/blog/inside-browser-part3/"},"children":[{"type":"text","value":"Inside look at modern web browser (part 3)"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://alistapart.com/article/braces-to-pixels/"},"children":[{"type":"text","value":"Braces to Pixels"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://web.dev/preload-scanner/#whats-a-preload-scanner"},"children":[{"type":"text","value":"Don’t fight the browser preload scanner"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"excerpt":"이 글은 Google Chrome 개발자 Steve Kobes의 Life of Pixel영상을 보고 정리한 내용입니다. 사용된 이미지들은 Steve Kobes의 허락\n하에 slide show에서 가져왔습니다. 이 글의 목표 어떤 과정을 통해 HTML…","timeToRead":9,"frontmatter":{"title":"Life of Pixel","userDate":"26 September 2022","date":"2022-09-26T12:00:00.000Z","tags":["composite","layer","렌더링"],"excerpt":null,"image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACVElEQVQoz51R224SURSdP+kX9aHf0CcexAeQhqgNWDMVGkUpRi1taG01UYwpJVZJuAQKtQVxuMwwLWWoWGinlqkw3HpRlnNOg6mxvriTlX05a6+9sw+zlZVRzB9hhz8CiUtCHVLhWIMCSVBQ1uJi/hu2c4coi98pCHfgxcwBSnyd9pF+hhAJSHIhftFMiMQXMvsURFz4XAOfrtIh5H3AIcKDhRgiEFzdxPuVOBV7sbAM+6QTrkdzePb4OdiJ+9iIFbAZE2m+MOfF0vxbjN+8i5U3IVSlDjzuV5iffY3KtgqmpE1eXY7Bxj7Eu+Uoph2zsI7f08gRTE44cP3aDSTCPAL+dTimnsL95CXYOw8wNTmtDdlCKrEDk+EWTMbbSH8sXWwocDWEPiQRC2bAbe5qD0WURBkb8RxCgXVk0zs0DwUSCGrIpIrguV1aSyZ4iPmvyHOSFotgChy5BfmMY+0OCkROu192D5dtLb6G1KcU/mWRSAT5fBYV6QjMYU2FXFVxsNfQfJPGX6R9sCwLm82GSqUCs9mMaDSKXC4Ht9sNv99Pc6PRCEEQsLi4BJPJhG77B5irJsqHMnQ6HUZHR+l0l8tFhRqNBoaGhuD1eqHX6zEyMoJwOEw5BoOB9jL9fh+/8bNPi4qiYHh4GFarFeVyGXa7HTMzM0gmk3A6nfD5fHRLj8dD+cSPjY1BluU/NySixOr1OiwWC92I1Hq9Hk5OTiiInZ+fU99ut9HpdHB6eoput0v7rhQ8OzujxFarBVVVqR+g2WzSGvGX66RGhP+64UD0f+0XH6I/ueaBdj4AAAAASUVORK5CYII=","aspectRatio":1.7312775330396475,"src":"/static/2b0a5b085c18b03f9da9d19388f94f50/3a40b/life-of-pixel.png","srcSet":"/static/2b0a5b085c18b03f9da9d19388f94f50/3a40b/life-of-pixel.png 786w","sizes":"(max-width: 786px) 100vw, 786px"}}},"author":[{"id":"4기_병민","bio":"우아한테크코스 4기 병민(윤병인)입니다 :)","avatar":{"children":[{"__typename":"ImageSharp","fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEUklEQVQ4y7WUaVBbVRTHz0ssdKBALUtIIAtJAwSQJQ1LAAuFapHN1qG0oSDKUrYWrEha1qQIkUiCrBIW2aUGKKAoOGUZse0A4tTadphxwy/VcZlxHKc6aMg7vgT9YrB+8j9zZt599/1/Z7lvLsA/xOe6gUjoAUIPNhykItBPRIgD/GhB/r60AF9vmkjIJ9hMZ3BzOWDef6g8OCzw9/ECbyEfhHwOkZwYT3gJeBDgJzK/Nz072FpDqCSI7sFmEQJzcr7ZZyGmiyNw3VzNJhPMU8CF5MQEqlKOh59IeMTX62CMJ5/rZ2NF2IdKxMBhuQCPzSQEPHezzxLofMC8QYEIKjtw3V2dDwU+NhYRFvxHpDQUTREeGoxhweJvqIrV+/dZW7m7OgEFJHjuzN0q3AESO8s9Ik/BWphEjIcjpGRUpNQYExVpjI1+nKQCpcFipBK/+7f3X4EcFoPOc3elwIxUNouBDBenLbYbk+Rx2aRQ4EEK+DySy+UYOWz333lsFrKZLqdNrZt8FsA+eRpw3FzpNnb24OT4aG2QNw8nVYWGm311+L7uZVKvKcfO6iKyrlCGp4+GGNiuTkjNvYXh7AjUdCyB3y4MApXRvEHbY1WT93QU3hqsNczrasmfbugRP1vEB6tX8Y7+NfxCrzIkhPujja1NAxCPmA7IEvj5uAY8eSy6g50N2NnZZpRnxOF000XD6Cul5I0eBf4w34vLXTVoWo/Xn9s+FXMIKVuSybvffh/NArigPU98feUyfD+tZowpsu71VOTgO7p6Y1lmMjmhkeMK1XpvVR52VuaTM80VmJcU8UAWKxFLvHlwPEpsCbw9eJm4P9sJPy71u803Fv6iV5XgxtyIcVynwWt9jbg+1IDd6mqyRXEBPxhqMnSXpuFiY0HbsrYA5huLLFte666AS/E+RHG4Myxpz01NqwpwY3Zoe3NhlPx0REV+OaHBj/Rt+Ou9ZfL6cJPxrapn8e6QMv3uQA3lLbcE3hmqhUlFJkQ5UjMBsJpV5V5f7a7CGXXx9vpgHa711pArPdXkQkcleU1bYrxafeYK3l/d+9uqHtZ7Ki3/w1v9CphVnYXxqnR6X0kytJ99ouiTAQVqC2VbqaFiMiNairlxkVu3B5Q4UXVm6bv3WqGtIAFuvi4HqnpLYFt2LHQVPgVqWdjOrQNgra+QrazqLuLkpSzDG/knDXPq8zjXkGdUnggMqUjwgZGyFPpKpxw2Rut3v20684+BOk0KTZmHCfkxT5CJ9jqMVaaNfdheisutF3CyJuPjupOSiObnj8DgiydoU8rnQJsRCdQ3uwO1GRHQkXsU2qlozY6hVSb6wleTGhiVn4p7syw1CRFBQwGGX0qhLTYVw+Zksxn4UL1KVWiaYVdhPAWNJXBziZhSZpoPzKTuonjaTF0O/Lw8DI3pEZAT7Qf/KWVKCPS/cBw68p6EluwYeLs2y9QerYVqVVcQR7X7DDT8Nev/XX8CdhmoO69DZOgAAAAASUVORK5CYII=","aspectRatio":1,"src":"/static/1433f8cacf09f3065859dc83e5fd95b2/202a6/by.png","srcSet":"/static/1433f8cacf09f3065859dc83e5fd95b2/22f7f/by.png 40w,\n/static/1433f8cacf09f3065859dc83e5fd95b2/587c9/by.png 80w,\n/static/1433f8cacf09f3065859dc83e5fd95b2/d966b/by.png 120w,\n/static/1433f8cacf09f3065859dc83e5fd95b2/202a6/by.png 421w","sizes":"(max-width: 421px) 100vw, 421px"}}]}}],"source":null}},"relatedPosts":{"totalCount":1,"edges":[{"node":{"id":"5be56cd5-7510-54c2-b008-901b081b58cd","timeToRead":9,"excerpt":"이 글은 Google Chrome 개발자 Steve Kobes의 Life of Pixel영상을 보고 정리한 내용입니다. 사용된 이미지들은 Steve Kobes의 허락\n하에 slide show에서 가져왔습니다. 이 글의 목표 어떤 과정을 통해 HTML…","frontmatter":{"title":"Life of Pixel","date":"2022-09-26T12:00:00.000Z"},"fields":{"slug":"/post/2022-09-26-life-of-pixel/"}}}]}},"pageContext":{"slug":"/post/2022-09-26-life-of-pixel/","prev":{"excerpt":"본 포스팅은 도커에 대한 자세한 개념, 도커 기본 명령어, 컨테이너 실행 실습, 도커 컴포즈, 도커 이미지 빌드, 도커 허브에 이미지 배포 등 전반적인 도커 기초에 대한 내용을 다룬다. 도커 (Docker…","timeToRead":21,"frontmatter":{"title":"이론과 실습을 통해 이해하는 Docker 기초","tags":["docker"],"date":"2022-09-25T12:00:00.000Z","draft":false,"excerpt":null,"image":{"childImageSharp":{"fluid":{"aspectRatio":1.7782026768642447,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABUUlEQVQoz51Ty0rDQBSdT/AHXfgVrlyKiAvRhVBw40IXrmxFax/WQqmIxbbUIlRa1NIkZvJonKTQpJ0cm9AmMWoxXrjM48w9M+dwhyASrusGY3SeJMhPBFPOg72kxCR6mMeKuDvHIuTLMiD8QsanyD52oH6w0Io/yvVISZTdHNtYPcliZeMAh7cNbN338CBqPqYrCphhYKipUCgFlWXoQwNU02Bao/CFvmfzRaraAtlOg+wVQHYusH5Vg2FasGfa088C2rKOfFfA3auEpqii2x8gX6ni/LqMsW2Hkhdyh+YIZ+0e1i6bSNW6gRTTmWKzJSHVUbD7RP3xtM/QEyRkiiXsHx2DWVb4Qi8MxpAplJAr3aBRryNXLCJbruBtVoSkHnph2w4kqvgEIlXxIogYSO9wJhMf92zhsVz4z+dt9q1tlt0cX//2CUgc4JFb+T8a+xNizEr+5AuV8QAAAABJRU5ErkJggg==","sizes":"(max-width: 1920px) 100vw, 1920px","src":"/static/40a730f43ffb6c029e36c9be353f9f92/0e6e2/docker-basic.png","srcSet":"/static/40a730f43ffb6c029e36c9be353f9f92/3a443/docker-basic.png 930w,\n/static/40a730f43ffb6c029e36c9be353f9f92/4d929/docker-basic.png 1860w,\n/static/40a730f43ffb6c029e36c9be353f9f92/0e6e2/docker-basic.png 1920w"}}},"author":[{"id":"4기_후디","bio":"우아한테크코스 4기 후디(조동현)입니다 :)","avatar":{"children":[{"fluid":{"aspectRatio":1.0050251256281406,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEwklEQVQ4yx2U61fSBxjHf//DztZp7bQsu2zVqC1dtWyghmihgMjlBz+uiYCAIBIiKMjlByKigoBc5OYFSLl4v4SC10q32lbbi7UuW1k7a+vN/oHRzvm+eN48z+d7Pi8egAGS6FRqHY5SfYPaQL5JAzk0kMtiClhskbTlFostxBNZuHomoYFNhwScmxIGg08gMrG1tOtYKlCPreHQSVwmRKFAWBxUjcGTiRQBX8oTKLwul1qth9hSJlfKYIkhZjODKaRQuNg6EI0hXqsiAJjKmnJkdXkVpgFfq5SJxAI+kUACGQIaS2q39atUOiqNT6PzIaZQLFbQIV49sdCCQyRxGsgcgEoGEV+W8aR6uWbQbND7HZYGPFbE50EMLr6eRaE2gpCAzpRIpJr4aEjS0gEyxFRISCCyCnygvBJ78Qqm152698u/ixtPA+NZocxwo5ZEp5B6tDK3pRVW8RgkPBpVAVEalC08DlhfhSwjViP5FAzgtJlUynZHcHH70bvs/VfZ3dfZuy/DU/d1Zn9malIs4KllbHu3QN5EkjWRWti1hMpSCafWaeD7esTAN1cx31bgw5Pb9x7/s/Fgf3Hz2Vzu16WN33Z+eLv13RuosQOBKI359MmweSneB8tZ504dteuE6VF4bLgTOFeCKqvAp1Yebzx4u7D5bGnrWYF8Z/PJ6IA1l/9J3G5HISvmxnoXY/3r08N9qkbM5fOpIJwKw3G/Dii5jEZjweXtF5sP/17be7O0/Txz59Fi/knEG4rYtAqpHIlC5zPuh/mxvbVoxNri13JX086FmD0TsQAXr1bjyI2ru/vr3/+1svP70tbz7M4f+d1XOz++y8xsejU8r6E5N+Nan+nPJq2JgDYZ1G3ODqwmB+fG7cAVFJbGkRWYub03d+6+LFQoOJ/N/jyffbyy9ZzBbRXQ65xmadR5K5fuTfg7UyHdYsyYDHStTDoK5Ossvmp178+Vuy+z9/bXdl/n7u+v7rxYXn+S237aKlXQ8OhEAM5EzXPjptkx00IcjrmVQZskm3QCFRWYOhxZ1KKWKvRKjU2lHdSaho3WEbhvNBJJ+XvkHi0rP+OZCpnSEUM6YpmPW8fdCp+1NZscAqYjloK9+HC3z9busrSdPnGsmU10wm19hjaPrSPQp4y5NMu3HWFX52RQnwpqkyOaqYBmOmpeSw0BhWPpsLmgbnLEFPcZEJ+dcJhkW7PuQtYz7rW050E2lJ92+fvbE4HuhQljJtQV8ygzYfh97UTAePv/JPzG4KD68+KiAZM8MdI75rWOuCzDA3DY3eNzwD1dorBDGRtWT0d0M1Hd/IR1+fYAMOEzxP3GCa+hMAzC8jMnjvAa+Ye/oh6/xDz6Na2olP7pBfAQgqiUsC1tZFJNGZdSZVFCsxHj/EQfEHJqIy5d2NU96jF0yLjHiw5DNPBMCebsJVxRCeXQeepBBOnD0ziFiDlu40uZNc0g2qmG0gHt+2X/gCbo6AoN6eIBWCagnyo+UvgKHxRf+wSBO/gF8ePz5ANnCR+dxsn5tKi1ySgDNUKCV88ZG+qMB3qBkEMXdRsi7u501C5qpJ0sPkrmtB24wDmGbD6GEp+slB4vl5xE8ky32CEzt62JDNaiPF0MWC3hNyv+A081WE3LGkRBAAAAAElFTkSuQmCC","sizes":"(max-width: 800px) 100vw, 800px","src":"/static/e88c3ca6c1dcd01f0a3a4db5b3373c50/bc8e0/hudi.png","srcSet":"/static/e88c3ca6c1dcd01f0a3a4db5b3373c50/8ac63/hudi.png 200w,\n/static/e88c3ca6c1dcd01f0a3a4db5b3373c50/3891b/hudi.png 400w,\n/static/e88c3ca6c1dcd01f0a3a4db5b3373c50/bc8e0/hudi.png 800w,\n/static/e88c3ca6c1dcd01f0a3a4db5b3373c50/6050d/hudi.png 1200w,\n/static/e88c3ca6c1dcd01f0a3a4db5b3373c50/97244/hudi.png 1326w"}}]}}]},"fields":{"layout":"post","slug":"/post/2022-09-20-docker-basic/"}},"next":{"excerpt":"…","timeToRead":7,"frontmatter":{"title":"공식 팀에서의 에러 헨들링","tags":["React","ErrorHandling"],"date":"2022-09-30T12:00:00.000Z","draft":false,"excerpt":null,"image":{"childImageSharp":{"fluid":{"aspectRatio":2.2794117647058822,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAACCklEQVQozxWRTU8TQQCGp93dmd353NmP6eywW7atfFgVS0tLk0IEBYQaYjARiwkc9KDpBQ/iwZhovBk5yUlj/AXGGA8evfgDMMaTNy9evRE/LsIPePPkeV5wffNap9WYPlO7v3t7/9njldW1ETM6PjYeRpFKVLdcvpvXtn11q+gOXH/Ie3vtqyIQRuvLl2bB+tK8DuVERX989/rNy/0szRKdpuWRklaVtLKAxRCAV1bhezX8LIsPC9mL1sDE0hciHzVgo7+c6CQ1envzSrfTDGTkeYQLPw5VFph5LA4A+N2oHPXqfwczPyZHDtK5XEoPYwg9ABGq5enK3Izgvm1j7DFCmOAyELH2db/ofmlUj7r5T4F/9cf+rE69TbqnpI8J8ZALlnut1vnTawuzcRi5LqGUhZHK8olARDrQKwXyoZv+26h85c43WDwE9vPa4rTRhPFjBpidrjMuxvKyUcqBngdh9Wyrf+dJkk/ELFoicgCK7xv8sGk+nZvccbIH1dVuaiChmAhAKYUIJ7HyGYMOogTHSWlqcT2vt2Op6r5qm2qdli7yoJk0J1s3Ht17urc7xMiGiAAIXYRO7CFELvKEECqSxz8FpSwOYukxRWWIvNhxU4fWqd5pXLjZaVi27UAX2DZ0HHSyPI5FGWWCcZ9yjjknzGcW9AoWLjohsEzBMcDaCitb1RQULITIf/h4UsBg5jESAAAAAElFTkSuQmCC","sizes":"(max-width: 1140px) 100vw, 1140px","src":"/static/cade1b68d460df441ec965846585032f/b8ffe/error-handling.png","srcSet":"/static/cade1b68d460df441ec965846585032f/3a443/error-handling.png 930w,\n/static/cade1b68d460df441ec965846585032f/b8ffe/error-handling.png 1140w"}}},"author":[{"id":"4기_자스민","bio":"우아한테크코스 4기 자스민(황정민)입니다 :)","avatar":{"children":[{"fluid":{"aspectRatio":1,"base64":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAQEAAwAAAAAAAAAAAAAAAAgGBAcJ/8QAFgEBAQEAAAAAAAAAAAAAAAAABgcI/9oADAMBAAIQAxAAAAGuN7PmmFJ+1nFVAV4x08GkEfjQwT//xAAcEAABBQEBAQAAAAAAAAAAAAAEAQIDBQYABxP/2gAIAQEAAQUCdJWCRsDrnuUILiJ5jIaux0pZn3TvM9NcP1+s29+teu92ru//xAAkEQACAQQBAgcAAAAAAAAAAAABAgMEERIhABNBFBUyUXGRkv/aAAgBAwEBPwGlgEFLFF4CnrRLTrLLPGqVBUuOpYsqsclBCY5BkbVj2LAkkaF9fHKFm8pc5Nfp1O7m+o3t9dvbhd7+pv0ef//EACgRAAIBAwIDCQEAAAAAAAAAAAECAwQREgAFEzFiBhQVISIkQUNRof/aAAgBAgEBPwHdJZKncKifxmp254arh09I1Q1OrIoSO+PFCJexkbIEH1CTFlZWWIhVDKCwABNuZsL/AN1usEJ7XQIYYinettGJjXGzTwBhja1mucv25vz0KOj8va03x9EXT06//8QAJxAAAgIBAwIFBQAAAAAAAAAAAgMBBBIABRETIgYUITGhMjNBYXH/2gAIAQEABj8COxdGnVrJESc9p4qXmYgEmw8YGJIhH+kMe86hPSrQ+QJgr5GGyAFAEfTyzlYmQiR8YiRCMlBFET61Vc/n1nT2bQUss1mpFyFuSdqHJYJdtVuAyuJWIsSRSNhDZKJn10t+47cxDloZTizZ26hSkVuaFg466DI3fY7EqxXlibYIgE4+rVqzasxeYza7DJ80pUxDPMVo6g9EUzBYkQ+/GM8ca38K9hdGdtrV7VZtReLev5lAQRk0nZREMPs4gJ57xLXM+KN45/VnD4ABj41//8QAHRABAQADAAIDAAAAAAAAAAAAAREAIUExUWGxwf/aAAgBAQABPyGNJMekwDA2mMDFLqEaCoJveUwl0iaidPMp7zbo5iSGArgcYi/hMLFINRBl6LN635+/nOFUyR19BbCDCRIZnoN1xwcgDJp3Id/Y7Z//2gAMAwEAAgADAAAAEGvwgv/EABwRAQEAAgIDAAAAAAAAAAAAAAERAGEhUYGR8P/aAAgBAwEBPxA3u4Phv9Xh0UuSIESK8JEPB92MwVQVNdtqBVqBImUNXoN6M//EABwRAQACAgMBAAAAAAAAAAAAAAEAESFBMVFhgf/aAAgBAgEBPxBmjwVganGJYMq+maYRXG0v18jSAxnNExpiqIBFdLpQP//EABgQAQEBAQEAAAAAAAAAAAAAAAERACFB/9oACAEBAAE/EDUjBaegnRkhgASET/zutjQwcuMu1JwGQygyUt0XlTp6D09mQbWzIhBrf5CcBEwqUqrVV6enrV7m9z8b1lZob4JIInNDTvGmWY0QiKtBViVVoC9UCf/Z","sizes":"(max-width: 460px) 100vw, 460px","src":"/static/7246b084cfd523c5835ec9c0f7dfd50a/f86e8/jasmin.jpg","srcSet":"/static/7246b084cfd523c5835ec9c0f7dfd50a/fd013/jasmin.jpg 200w,\n/static/7246b084cfd523c5835ec9c0f7dfd50a/25252/jasmin.jpg 400w,\n/static/7246b084cfd523c5835ec9c0f7dfd50a/f86e8/jasmin.jpg 460w"}}]}}]},"fields":{"layout":"post","slug":"/post/2022-09-30-error-handling/"}},"primaryTag":"composite"}},"staticQueryHashes":["2130001345","4041952199"]}