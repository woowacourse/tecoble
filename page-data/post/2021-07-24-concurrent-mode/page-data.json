{"componentChunkName":"component---src-templates-post-tsx","path":"/post/2021-07-24-concurrent-mode/","result":{"data":{"logo":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","backgroundColor":"#080808","images":{"fallback":{"src":"/static/0b18bd94a62a12fdc81ea720c28722f6/a9770/tecoble.png","srcSet":"/static/0b18bd94a62a12fdc81ea720c28722f6/a9770/tecoble.png 400w","sizes":"400px"},"sources":[{"srcSet":"/static/0b18bd94a62a12fdc81ea720c28722f6/65935/tecoble.webp 400w","type":"image/webp","sizes":"400px"}]},"width":500,"height":110}}},"markdownRemark":{"html":"<p>❗ react suspense에 대한 이해가 필요한 글입니다. 사용자 경험 개선 1편을 참고해주세요.</p>\n<h2>👀 concurrent mode란 무엇인가</h2>\n<p>자바스크립트가 싱글 스레드 언어라는 것을 들어본 적이 있을 것이다.\n이는 자바스크립트가 하나의 작업을 수행할 때 다른 작업을 동시에 수행할 수 없음을 의미한다. 리액트도 자바스크립트 기반이기에 물론 싱글 스레드이다.\n하지만 리액트에서 <code class=\"language-text\">concurrent mode</code>를 사용하면 여러 작업을 동시에 처리할 수 있다.\n오늘은 concurrent mode에 대해서 같이 알아보자.</p>\n<p>우선 여러 작업을 동시에 할 수 있다면 어떤 점이 좋은지는 잠깐 미뤄두자.\n필자는 개인적으로 두 눈으로 본 것 아니면 의심하는 경향이 있다.\n리액트가 <code class=\"language-text\">정말 한 번에 하나의 작업만 처리하는지</code>부터 확인해보자.</p>\n<p>예를 들어 리액트는 UI 렌더링 도중에 렌더링 이외의 모든 작업을 차단한다. ‘렌더링 도중에 모든 작업을 차단한다고?’ 현재 리액트를 버벅임 없이 사용하고 있는 개발자들은 의아할 것이다.</p>\n<iframe src=\"https://codesandbox.io/embed/blocking-mode-ogob4?fontsize=14&hidenavigation=1&theme=dark&view=preview\"\n     style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n     title=\"blocking-mode\"\n     allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n     sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n   ></iframe>\n<p>위의 예제에서 아무 값이나 입력해보자. 예제에서는 사용자의 입력이 들어올 때마다 5,000개의 DOM element가 생성된다. 정상적으로 값을 입력하지 못할 정도로 버벅댈 것이다. 실제로는 5000개의 DOM element를 생성할 일은 거의 없지만, 렌더링 도중에 다른 모든 작업을 차단하는 모습을 직접 눈으로 보는 데에는 이만한 예제가 없다.</p>\n<p>그렇다면 이런 의문이 들 것이다. 자바스크립트 자체가 싱글 스레드라면, 리액트에서 동시에 작업을 처리하는 것은 불가능한 것 아닌가?\n하지만 리액트 개발자들은 방법을 찾아냈다. 바로 <code class=\"language-text\">동시성</code>이다.</p>\n<p>동시성은 여러 작업을 작은 단위로 나눈 뒤, 그들 간의 우선순위를 정하고 그에 따라 작업을 번갈아 수행하는 방법이다. 서로 다른 작업들이 실제로 동시에 수행되는 것은 아니지만, 작업 간의 전환이 매우 빠르게 이루어지면서 동시에 수행되는 것처럼 보이는 것이다.</p>\n<p>예시로 게임에 빠져 살던 시절 필자는 컴퓨터를 앞에 두고 밥을 같이 먹은 적이 종종 있었다. 게임에 중요한 상황이 있으면 마우스와 키보드를 잡았다가 게임에 신경 쓰지 않아도 되는 타이밍에 빠르게 밥과 김치를 입에 넣곤 했다.\n손이 2개밖에 안 되어 실제로 식사와 게임을 <code class=\"language-text\">동시에</code> 하진 못했지만 작업 간의 전환을 빠르게 하여 동시에 수행하는 듯 보였다.</p>\n<p>이렇게 리액트는 동시성 개념을 도입해 싱글 스레드 환경에서 여러 작업을 동시에 할 수 있게 되었다.</p>\n<h2>🤔 여러 작업을 동시에 처리하는 것이 왜 중요한가요?</h2>\n<blockquote>\n<p>concurrent mode가 왜 필요한 건가요? 이렇게까지 동시성을 구현할 필요가 있었나요?</p>\n</blockquote>\n<p>이러한 의문이 드는 것은 자연스러운 일이다.\nconcurrent mode는 사용자 경험과 굉장히 밀접한 관계가 있다.\n사용자 경험을 저해하는 어떤 상황에서 concurrent mode가 빛을 발하는지 대표적인 사례를 알아보자.</p>\n<h3>1. 기존 디바운스와 쓰로틀의 한계</h3>\n<p>사용자가 input을 입력할 때마다 <code class=\"language-text\">무거운 작업</code>을 수행하는 경우 버벅거림을 경험해본 적이 있을 것이다.\n예를 들어 응답을 받는 데 시간이 걸리는 네트워크 요청이라든지, 많은 DOM element를 생성한다든지 하는 작업이 있다.\n필자는 이 문제를 해결하기 위해서 <code class=\"language-text\">디바운스와 쓰로틀</code>을 사용해 해결한 적이 많았다.\n확실히 이를 사용하면 무거운 작업의 수행 빈도수를 줄여주어 버벅거림은 줄어든다.\n하지만 분명한 한계점들이 있다.</p>\n<ul>\n<li>\n<p>디바운스\n디바운스는 사용자의 마지막 입력이 끝난 뒤 일정 시간이 지나면 무거운 작업을 수행하는 방법이다.\n하지만 이 방법은 기기의 성능과는 관계없이 무조건 <code class=\"language-text\">일정 시간</code>을 기다려야 한다는 단점이 있다.\n슈퍼컴퓨터든 10년 된 컴퓨터든 똑같이 마지막 입력 이후에 0.5초를 기다려야 한다면 슈퍼 컴퓨터 입장에서는\n안타까울 수밖에 없다. 또한 사용자 입력 중에 무거운 작업의 처리가 이뤄지지 않는다는 점도 아쉬울 수 있다.</p>\n</li>\n<li>\n<p>쓰로틀\n디바운스에서 ‘입력 중에 무거운 작업의 처리가 이뤄지지 않는 점’은 쓰로틀로 개선할 수 있다.\n쓰로틀은 입력 중에 주기적으로 무거운 작업을 수행하는 방법이다.\n하지만 이 방법 또한 모든 사용자 경험을 높이는 방법은 아니다.\n쓰로틀 주기를 짧게 가져갈수록 성능이 좋은 기기에서는 사용자 경험을 높일 수 있지만\n성능이 나쁜 기기에서는 버벅거림이 심해지기 때문이다.</p>\n</li>\n</ul>\n<p>concurrent mode는 이러한 디바운스와 쓰로틀의 한계점들을 동시성으로 해결한다.\n빠른 작업 간 전환으로 사용자 입력과 무거운 작업이 버벅대지 않고 동시에 처리되는 경험을 사용자에게 줄 수 있고\n작업 처리 속도는 개발자가 설정한 delay에 의존되는 것이 아니라 사용자의 기기 성능에 좌우된다.</p>\n<h3>2. 충분히 렌더링이 빠름에도 의미 없는 로딩을 보여주는 경우</h3>\n<p>suspense로만 구현된 로딩은 이전 페이지를 유저로부터 <code class=\"language-text\">차단(block)</code>하고 다음 페이지의 전체 로딩 화면으로 대체하므로\n사용자는 답답함을 느끼게 되었다.</p>\n<iframe src=\"https://codesandbox.io/embed/concurrent-mode-1-v5e9v?fontsize=14&hidenavigation=1&theme=dark&view=preview\"\n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"concurrent-mode-1\"\n  allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n  sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n></iframe>\n<p>위 예제에서 <code class=\"language-text\">페이지 방문하기</code> 버튼을 누르면 이전 페이지를 모두 차단하고 다음 페이지의 <code class=\"language-text\">전체 로딩 화면</code>을 띄운다.\n특히 예제를 보면 전체 로딩 화면이 아주 짧게 나오는 것을 확인할 수 있는데 사용자에게 피로감을 줄 수 있는 불필요한 로딩은 최대한 줄이는 것이 좋다.</p>\n<p>이를 concurrent mode는 일정 시간 동안 현재 페이지와 기능들을 유지하고 다음 페이지에 대한 렌더링을 동시에 진행함으로써 해결한다.\n그리고 다음 페이지의 <code class=\"language-text\">렌더링 단계가 특정 조건에 부합하면</code> 해당 페이지를 렌더링한다.\n그렇다면 여기서 렌더링 단계와 특정 조건은 무엇일까? 같이 알아보도록 하자.</p>\n<h2>🎯 Concurrent mode의 동작 원리</h2>\n<p>위에서 언급한 concurrent mode의 동작 원리를 자세하게 풀자면 다음과 같다.</p>\n<blockquote>\n<p>특정 state가 변경되었을 때 <code class=\"language-text\">현 UI를 유지</code>하고 해당 변경에 따른 UI 업데이트를 동시에 준비.\n준비 중인 UI의 <code class=\"language-text\">렌더링 단계</code>가 <code class=\"language-text\">특정 조건</code>에 부합하면 실제 DOM에 반영한다.</p>\n</blockquote>\n<p>현 UI 상태를 유지한다는 것은 크게 어렵지 않으리라 생각한다.\n그럼 렌더링 단계와 특정 조건은 뭘까? 같이 알아보자.</p>\n<h3>렌더링 단계</h3>\n<p><img src=\"https://user-images.githubusercontent.com/48755175/126877704-3085e031-bc14-4430-a1e3-b8d5ccc46456.png\" alt=\"image\"></p>\n<p>Transition, Loading, Done 총 3개의 렌더링 단계가 있다.\n일반적으로 UI 업데이트는 state의 변경에 의해 발생하므로\n각 단계는 특정 state 변경의 관점에서 보는 렌더링 단계이다.\n오른쪽으로 진행할수록 더 최신 렌더링 단계이다. 각 단계에 대해서 조금 더 알아보자.</p>\n<ol>\n<li>\n<p>Transition 단계\nTransition은 state 변경 직후에 일어날 수 있는 UI 렌더링 단계이다.</p>\n<ul>\n<li>\n<p>Pending 상태\n리액트에서 제공하는 <code class=\"language-text\">useTransition 훅</code>을 사용하면 state 변경 직후에도\nUI를 업데이트하지 않고 현 UI를 잠시 유지할 수 있는데 이를 Pending 상태라고 한다.</p>\n</li>\n<li>\n<p>Receded 상태\nuseTransition 훅을 사용하지 않은 기본 상태. state 변경 직후 UI가 변경된다.\n전체 페이지에 대한 로딩 화면이라고 생각하면 이해하기 쉽다.\nPending 상태에서도 Receded 상태로 넘어갈 수 있는데 Pending 상태의 시간이 useTransition 옵션으로 지정된 timeoutMs을\n넘으면 강제로 Receded 상태로 넘어간다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Loading 단계</p>\n<ul>\n<li>\n<p>Skeleton 상태\n페이지의 일부만을 로딩하는 상태. 전체 화면을 모두 로딩으로 대체해버리는 Receded와는 다르다.</p>\n<iframe src=\"https://codesandbox.io/embed/concurrent-mode-3-xmtup?fontsize=14&hidenavigation=1&theme=dark&view=preview\"\n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"concurrent-mode-3\"\n  allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n  sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n></iframe>\n<p>위 예제에서 크루들의 닉네임을 눌렀을 때 설명 부분의 로딩 UI가 Skeleton 상태라고 할 수 있다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>Done 단계</p>\n<ul>\n<li>Complete 상태\n로딩 UI 없이 모든 정보가 사용자에게 보이는 상태를 의미한다.\n우리가 최종적으로 목표하는 단계라고 볼 수 있다.</li>\n</ul>\n</li>\n</ol>\n<h3>특정 조건</h3>\n<p>이제 렌더링 조건은 알 것 같다. 그렇다면 UI 업데이트를 실제 DOM에 적용하기 위한 <code class=\"language-text\">특정 조건</code>은 무엇일까?\n이 부분은 <a href=\"https://ko.reactjs.org/docs/concurrent-mode-patterns.html\">리액트 공식 문서</a>에서도 모호하게 나와 있어 정확하게 알기는 어려웠다.\n하지만 concurrent mode의 원리 중 하나인 <code class=\"language-text\">현재 UI를 유지한다</code>에 암시된 의미와 필자가 실험해본 결과를 조합해보았을 때,\n<code class=\"language-text\">특정 조건</code>이란 다음과 같다고 볼 수 있다. (혹시 잘못된 점이 있다면 알려주세요)</p>\n<blockquote>\n<p>특정 state 변경에 대한 현 화면의 UI 렌더링 단계보다 더 <code class=\"language-text\">최신 단계</code>로 진행하여야 실제 DOM에 반영한다.</p>\n</blockquote>\n<p>이해를 돕기 위한 다음의 예제를 보자</p>\n<iframe src=\"https://codesandbox.io/embed/concurrent-mode-4-6wgld?fontsize=14&hidenavigation=1&theme=dark&view=preview\"\n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"concurrent-mode-4\"\n  allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n  sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n></iframe>\n<p>예제에서 <code class=\"language-text\">페이지 방문하기</code> 버튼을 누르면 즉시 다음 페이지로 이동하지 않고 잠깐 현 화면을 유지하다가 다음 페이지의 Skeleton 상태로 이동한다. 이 과정을 자세히 들여다보자.</p>\n<p>먼저 버튼을 누르는 즉시 resource라는 state를 변경하고 Pending 상태에 진입한다.\n이때 백그라운드에서는 state에 대한 다음 페이지를 준비하는 Receded 상태에 머물러 있을 것이다.</p>\n<p>잠시 뒤 다음 페이지의 Receded 상태가 끝나고 Skeleton 상태에 진입하면 그때서야 실제 DOM에 적용한다.\nSkeleton 상태는 현 UI 상태인 Pending 상태보다 더 최신 단계이기 때문이다.</p>\n<p>이제 조금 헷갈릴 수 있는 상황이 등장한다.\n테코블 크루의 닉네임과 설명이 모두 렌더링 되어 Complete 상태로 넘어가고 다른 크루의 버튼을 눌러보자.\n버튼을 눌렀을 때 UI가 멈춰있는 Pending 상태에 진입하고 잠시 뒤 Skeleton 상태로 넘어갈 것 같지만\nSkeleton은 등장하지 않고 바로 다른 크루에 대한 정보가 렌더링 되는 Complete 상태로 넘어간다.</p>\n<p>여기서 간과하는 사실이 있다. 렌더링 상태는 렌더링을 유발하는 state 관점이라는 것이다.\n<code class=\"language-text\">페이지 방문하기</code> 버튼을 누르던, <code class=\"language-text\">크루의 버튼</code>을 누르던 resource라는 같은 state의 변경이 일어나고 있다.\n다시 한번 화면을 확인해보자. 크루의 버튼을 누르기 전에 resource state의 관점으로 봤을 때, Pending 상태가 아니라 모든 화면에 정보가 완전하게 보이는 complete 상태다.\n여기서 크루의 버튼을 누르면 Pending 상태나 Skeleton 상태로 전환되지 않는다. 현 UI는 Complete 상태로, Pending이나 Skeleton 상태보다 더 최신 상태이기 때문이다.\n그리고 백그라운드에서 새로운 resource state에 대한 렌더링이 Complete 상태로 넘어갔을 때, 그제야 실제 DOM에 적용한다.\n이전 state에 대한 Complete 상태보다 새로운 state에 대한 Complete 상태가 더 <code class=\"language-text\">최신 상태</code>이기 때문이다.</p>\n<h2>🔥 실제로 도입하기</h2>\n<p>지금까지는 concurrent mode가 동작하는 원리를 알아보았다. 이제 concurrent mode를 실제 코드에 적용하기 위해서는 어떻게 해야 할까?\nreact는 이를 위해 <code class=\"language-text\">useTransition</code>이라는 훅을 제공한다. useTransition을 사용한 다양한 패턴이 있지만, 필자가 구현해본 결과\n아직은 useTransition의 가장 간단한 사용법 정도를 훑어보는 정도면 충분할 듯하다. 아직 experimental이라 언제든 실제 구현 코드가 달라질 수 있기 때문이다.</p>\n<p>오늘 글에서 가장 먼저 예제로 등장했던 blocking mode input을 concurrent mode로 개선해보자.\n먼저 개선한 결과는 다음과 같다.</p>\n<iframe src=\"https://codesandbox.io/embed/concurrent-mode-5-ei5z8?fontsize=14&hidenavigation=1&theme=dark&view=preview\"\n  style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\"\n  title=\"concurrent-mode-5\"\n  allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n  sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n></iframe>\n<h3>1. react experimental 버전 설치</h3>\n<p>우선 concurrent mode는 experimental 버전에서만 동작한다. experimental 버전을 설치해주자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">npm install react@experimental react-DOM@experimental</code></pre></div>\n<h3>2. concurrent 모드 활성화</h3>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">//index.js</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ReactDOM <span class=\"token keyword\">from</span> <span class=\"token string\">'react-DOM'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> App <span class=\"token keyword\">from</span> <span class=\"token string\">'./App'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> rootElement <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">createRoot</span><span class=\"token punctuation\">(</span>rootElement<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>기존 blocking mode에서는 ReactDOM.render()를 사용했지만 concurrent mode를 사용하기 위해서는 createRoot()를 사용해야 한다.</p>\n<h3>3. state 반영 우선순위를 정하기</h3>\n<p>우리는 사용자가 input을 입력할 때 버벅거림을 줄이기 위해서 input state의 우선순위를 높게 줄 것이고\n5000개의 렌더링을 위한 array state는 우선순위를 낮게 주어 UI 업데이트가 지연될 수 있도록 할 것이다.</p>\n<p>❗ 주의 : 2021년 7월 기준 experimental 버전에서 useTransition의 리턴 형태가 [startTransition, isPending] => [isPending, startTransition] 으로 바뀌었다.\n유의하도록 하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// App.js</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isPending<span class=\"token punctuation\">,</span> startTransition<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useTransition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">timeoutMs</span><span class=\"token operator\">:</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 최대 3초 동안 다음 화면의 렌더링을 백그라운드에서 준비하겠다는 의미. 3초가 지나면 강제로 렌더된다.</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleChange</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">event</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setInput</span><span class=\"token punctuation\">(</span>event<span class=\"token punctuation\">.</span>target<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">startTransition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 지연할 UI와 관계된 state를 리액트에게 알려줌</span>\n    <span class=\"token keyword\">const</span> newArray <span class=\"token operator\">=</span> array<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">_<span class=\"token punctuation\">,</span> index</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">TECOBLE</span><span class=\"token punctuation\">[</span>index <span class=\"token operator\">%</span> <span class=\"token constant\">TECOBLE</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">setArray</span><span class=\"token punctuation\">(</span>newArray<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>handleChange 내부의 로직을 유심히 보자. setInput은 startTransition 바깥에서 실행되고, setArray는 내부에서 실행되고 있다.<br>\n이 차이는 state의 우선순위를 결정한다. setArray를 startTransition으로 감싸주는 의미는 ‘array state 변화는 지연시켜도 돼’라고 리액트에게 알려주는 것이기 때문이다.\n따라서 input state는 array state보다 높은 우선순위로 결정된다.</p>\n<p>이렇게 해주는 이유는 사용자의 입력이 5,000개의 DOM element를 렌더링하는 것보다 우선시 되어야 사용자가 입력할 때의 버벅임을 줄일 수 있기 때문이다.\n결과를 확인해보자. 이전 blocking mode로 구현했던 예제보다 훨씬 버벅임이 줄어들었을 것이다.</p>\n<h2>✨ 마무리</h2>\n<p>오늘은 사용자 경험 개선을 주제로 concurrent mode까지 알아보았다.\n1편에서 다루었던 suspense와는 다르게 concurrent mode는 react의 렌더링 방식을 크게 변화시키는 등\n앱 전반적으로 영향을 미칠 수 있는 터라 아직은 production 코드에서 사용하기에는 다소 무리가 있어 보인다.\n또한 예제 코드를 작성하면서 개인적으로 느낀 것은 concurrent mode를 지원하는 훅이 아직 직관적으로 사용하기가 불편하다는 생각이 들었다.\n(물론 내가 아직 concurrent mode의 개념에 익숙지 않아서 그럴 수는 있다 😂)\n하지만 concurrent mode는 곧 나올 React 18에 적용될 기능이기도 하고, 사용자 경험 개선에 있어서 도입하였을 때 많은 이점을 누릴 수 있는 기능이기에\n미리 공부하는 것이 나중에 큰 도움이 되리라 생각한다.</p>\n<p>오늘 주제에 관해 공부하면서 사용자 경험의 관점에서 많은 생각을 하게 되었다. 많은 로딩이 사용자 경험에 좋지 않다는 점을 알게 되었고\n디바운스와 쓰로틀에 대해서도 다시 생각해보게 되었다. 역시 무엇이든 완벽한 기술은 없다. 이를 염두에 두고 항상 불편함을 찾으며 개선하려는 자세를 가져야겠다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://velog.io/@cadenzah/react-concurrent-mode\">What is React Concurrent Mode?</a></li>\n<li><a href=\"https://ko.reactjs.org/docs/concurrent-mode-patterns.html\">concurrent mode UI 패턴</a></li>\n</ul>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"❗ react suspense에 대한 이해가 필요한 글입니다. 사용자 경험 개선 1편을 참고해주세요."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"👀 concurrent mode란 무엇인가"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"자바스크립트가 싱글 스레드 언어라는 것을 들어본 적이 있을 것이다.\n이는 자바스크립트가 하나의 작업을 수행할 때 다른 작업을 동시에 수행할 수 없음을 의미한다. 리액트도 자바스크립트 기반이기에 물론 싱글 스레드이다.\n하지만 리액트에서 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"concurrent mode"}]},{"type":"text","value":"를 사용하면 여러 작업을 동시에 처리할 수 있다.\n오늘은 concurrent mode에 대해서 같이 알아보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"우선 여러 작업을 동시에 할 수 있다면 어떤 점이 좋은지는 잠깐 미뤄두자.\n필자는 개인적으로 두 눈으로 본 것 아니면 의심하는 경향이 있다.\n리액트가 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"정말 한 번에 하나의 작업만 처리하는지"}]},{"type":"text","value":"부터 확인해보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"예를 들어 리액트는 UI 렌더링 도중에 렌더링 이외의 모든 작업을 차단한다. ‘렌더링 도중에 모든 작업을 차단한다고?’ 현재 리액트를 버벅임 없이 사용하고 있는 개발자들은 의아할 것이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"iframe","properties":{"src":"https://codesandbox.io/embed/blocking-mode-ogob4?fontsize=14&hidenavigation=1&theme=dark&view=preview","style":"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;","title":"blocking-mode","allow":"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking","sandbox":["allow-forms","allow-modals","allow-popups","allow-presentation","allow-same-origin","allow-scripts"]},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"위의 예제에서 아무 값이나 입력해보자. 예제에서는 사용자의 입력이 들어올 때마다 5,000개의 DOM element가 생성된다. 정상적으로 값을 입력하지 못할 정도로 버벅댈 것이다. 실제로는 5000개의 DOM element를 생성할 일은 거의 없지만, 렌더링 도중에 다른 모든 작업을 차단하는 모습을 직접 눈으로 보는 데에는 이만한 예제가 없다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"그렇다면 이런 의문이 들 것이다. 자바스크립트 자체가 싱글 스레드라면, 리액트에서 동시에 작업을 처리하는 것은 불가능한 것 아닌가?\n하지만 리액트 개발자들은 방법을 찾아냈다. 바로 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"동시성"}]},{"type":"text","value":"이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"동시성은 여러 작업을 작은 단위로 나눈 뒤, 그들 간의 우선순위를 정하고 그에 따라 작업을 번갈아 수행하는 방법이다. 서로 다른 작업들이 실제로 동시에 수행되는 것은 아니지만, 작업 간의 전환이 매우 빠르게 이루어지면서 동시에 수행되는 것처럼 보이는 것이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"예시로 게임에 빠져 살던 시절 필자는 컴퓨터를 앞에 두고 밥을 같이 먹은 적이 종종 있었다. 게임에 중요한 상황이 있으면 마우스와 키보드를 잡았다가 게임에 신경 쓰지 않아도 되는 타이밍에 빠르게 밥과 김치를 입에 넣곤 했다.\n손이 2개밖에 안 되어 실제로 식사와 게임을 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"동시에"}]},{"type":"text","value":" 하진 못했지만 작업 간의 전환을 빠르게 하여 동시에 수행하는 듯 보였다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 리액트는 동시성 개념을 도입해 싱글 스레드 환경에서 여러 작업을 동시에 할 수 있게 되었다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"🤔 여러 작업을 동시에 처리하는 것이 왜 중요한가요?"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"concurrent mode가 왜 필요한 건가요? 이렇게까지 동시성을 구현할 필요가 있었나요?"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이러한 의문이 드는 것은 자연스러운 일이다.\nconcurrent mode는 사용자 경험과 굉장히 밀접한 관계가 있다.\n사용자 경험을 저해하는 어떤 상황에서 concurrent mode가 빛을 발하는지 대표적인 사례를 알아보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"1. 기존 디바운스와 쓰로틀의 한계"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"사용자가 input을 입력할 때마다 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"무거운 작업"}]},{"type":"text","value":"을 수행하는 경우 버벅거림을 경험해본 적이 있을 것이다.\n예를 들어 응답을 받는 데 시간이 걸리는 네트워크 요청이라든지, 많은 DOM element를 생성한다든지 하는 작업이 있다.\n필자는 이 문제를 해결하기 위해서 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"디바운스와 쓰로틀"}]},{"type":"text","value":"을 사용해 해결한 적이 많았다.\n확실히 이를 사용하면 무거운 작업의 수행 빈도수를 줄여주어 버벅거림은 줄어든다.\n하지만 분명한 한계점들이 있다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"디바운스\n디바운스는 사용자의 마지막 입력이 끝난 뒤 일정 시간이 지나면 무거운 작업을 수행하는 방법이다.\n하지만 이 방법은 기기의 성능과는 관계없이 무조건 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"일정 시간"}]},{"type":"text","value":"을 기다려야 한다는 단점이 있다.\n슈퍼컴퓨터든 10년 된 컴퓨터든 똑같이 마지막 입력 이후에 0.5초를 기다려야 한다면 슈퍼 컴퓨터 입장에서는\n안타까울 수밖에 없다. 또한 사용자 입력 중에 무거운 작업의 처리가 이뤄지지 않는다는 점도 아쉬울 수 있다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"쓰로틀\n디바운스에서 ‘입력 중에 무거운 작업의 처리가 이뤄지지 않는 점’은 쓰로틀로 개선할 수 있다.\n쓰로틀은 입력 중에 주기적으로 무거운 작업을 수행하는 방법이다.\n하지만 이 방법 또한 모든 사용자 경험을 높이는 방법은 아니다.\n쓰로틀 주기를 짧게 가져갈수록 성능이 좋은 기기에서는 사용자 경험을 높일 수 있지만\n성능이 나쁜 기기에서는 버벅거림이 심해지기 때문이다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"concurrent mode는 이러한 디바운스와 쓰로틀의 한계점들을 동시성으로 해결한다.\n빠른 작업 간 전환으로 사용자 입력과 무거운 작업이 버벅대지 않고 동시에 처리되는 경험을 사용자에게 줄 수 있고\n작업 처리 속도는 개발자가 설정한 delay에 의존되는 것이 아니라 사용자의 기기 성능에 좌우된다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"2. 충분히 렌더링이 빠름에도 의미 없는 로딩을 보여주는 경우"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"suspense로만 구현된 로딩은 이전 페이지를 유저로부터 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"차단(block)"}]},{"type":"text","value":"하고 다음 페이지의 전체 로딩 화면으로 대체하므로\n사용자는 답답함을 느끼게 되었다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"iframe","properties":{"src":"https://codesandbox.io/embed/concurrent-mode-1-v5e9v?fontsize=14&hidenavigation=1&theme=dark&view=preview","style":"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;","title":"concurrent-mode-1","allow":"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking","sandbox":["allow-forms","allow-modals","allow-popups","allow-presentation","allow-same-origin","allow-scripts"]},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"위 예제에서 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"페이지 방문하기"}]},{"type":"text","value":" 버튼을 누르면 이전 페이지를 모두 차단하고 다음 페이지의 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"전체 로딩 화면"}]},{"type":"text","value":"을 띄운다.\n특히 예제를 보면 전체 로딩 화면이 아주 짧게 나오는 것을 확인할 수 있는데 사용자에게 피로감을 줄 수 있는 불필요한 로딩은 최대한 줄이는 것이 좋다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이를 concurrent mode는 일정 시간 동안 현재 페이지와 기능들을 유지하고 다음 페이지에 대한 렌더링을 동시에 진행함으로써 해결한다.\n그리고 다음 페이지의 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"렌더링 단계가 특정 조건에 부합하면"}]},{"type":"text","value":" 해당 페이지를 렌더링한다.\n그렇다면 여기서 렌더링 단계와 특정 조건은 무엇일까? 같이 알아보도록 하자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"🎯 Concurrent mode의 동작 원리"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"위에서 언급한 concurrent mode의 동작 원리를 자세하게 풀자면 다음과 같다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"특정 state가 변경되었을 때 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"현 UI를 유지"}]},{"type":"text","value":"하고 해당 변경에 따른 UI 업데이트를 동시에 준비.\n준비 중인 UI의 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"렌더링 단계"}]},{"type":"text","value":"가 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"특정 조건"}]},{"type":"text","value":"에 부합하면 실제 DOM에 반영한다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"현 UI 상태를 유지한다는 것은 크게 어렵지 않으리라 생각한다.\n그럼 렌더링 단계와 특정 조건은 뭘까? 같이 알아보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"렌더링 단계"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/48755175/126877704-3085e031-bc14-4430-a1e3-b8d5ccc46456.png","alt":"image"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Transition, Loading, Done 총 3개의 렌더링 단계가 있다.\n일반적으로 UI 업데이트는 state의 변경에 의해 발생하므로\n각 단계는 특정 state 변경의 관점에서 보는 렌더링 단계이다.\n오른쪽으로 진행할수록 더 최신 렌더링 단계이다. 각 단계에 대해서 조금 더 알아보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Transition 단계\nTransition은 state 변경 직후에 일어날 수 있는 UI 렌더링 단계이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Pending 상태\n리액트에서 제공하는 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"useTransition 훅"}]},{"type":"text","value":"을 사용하면 state 변경 직후에도\nUI를 업데이트하지 않고 현 UI를 잠시 유지할 수 있는데 이를 Pending 상태라고 한다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Receded 상태\nuseTransition 훅을 사용하지 않은 기본 상태. state 변경 직후 UI가 변경된다.\n전체 페이지에 대한 로딩 화면이라고 생각하면 이해하기 쉽다.\nPending 상태에서도 Receded 상태로 넘어갈 수 있는데 Pending 상태의 시간이 useTransition 옵션으로 지정된 timeoutMs을\n넘으면 강제로 Receded 상태로 넘어간다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Loading 단계"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Skeleton 상태\n페이지의 일부만을 로딩하는 상태. 전체 화면을 모두 로딩으로 대체해버리는 Receded와는 다르다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"iframe","properties":{"src":"https://codesandbox.io/embed/concurrent-mode-3-xmtup?fontsize=14&hidenavigation=1&theme=dark&view=preview","style":"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;","title":"concurrent-mode-3","allow":"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking","sandbox":["allow-forms","allow-modals","allow-popups","allow-presentation","allow-same-origin","allow-scripts"]},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"위 예제에서 크루들의 닉네임을 눌렀을 때 설명 부분의 로딩 UI가 Skeleton 상태라고 할 수 있다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Done 단계"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Complete 상태\n로딩 UI 없이 모든 정보가 사용자에게 보이는 상태를 의미한다.\n우리가 최종적으로 목표하는 단계라고 볼 수 있다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"특정 조건"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이제 렌더링 조건은 알 것 같다. 그렇다면 UI 업데이트를 실제 DOM에 적용하기 위한 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"특정 조건"}]},{"type":"text","value":"은 무엇일까?\n이 부분은 "},{"type":"element","tagName":"a","properties":{"href":"https://ko.reactjs.org/docs/concurrent-mode-patterns.html"},"children":[{"type":"text","value":"리액트 공식 문서"}]},{"type":"text","value":"에서도 모호하게 나와 있어 정확하게 알기는 어려웠다.\n하지만 concurrent mode의 원리 중 하나인 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"현재 UI를 유지한다"}]},{"type":"text","value":"에 암시된 의미와 필자가 실험해본 결과를 조합해보았을 때,\n"},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"특정 조건"}]},{"type":"text","value":"이란 다음과 같다고 볼 수 있다. (혹시 잘못된 점이 있다면 알려주세요)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"특정 state 변경에 대한 현 화면의 UI 렌더링 단계보다 더 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"최신 단계"}]},{"type":"text","value":"로 진행하여야 실제 DOM에 반영한다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이해를 돕기 위한 다음의 예제를 보자"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"iframe","properties":{"src":"https://codesandbox.io/embed/concurrent-mode-4-6wgld?fontsize=14&hidenavigation=1&theme=dark&view=preview","style":"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;","title":"concurrent-mode-4","allow":"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking","sandbox":["allow-forms","allow-modals","allow-popups","allow-presentation","allow-same-origin","allow-scripts"]},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"예제에서 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"페이지 방문하기"}]},{"type":"text","value":" 버튼을 누르면 즉시 다음 페이지로 이동하지 않고 잠깐 현 화면을 유지하다가 다음 페이지의 Skeleton 상태로 이동한다. 이 과정을 자세히 들여다보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"먼저 버튼을 누르는 즉시 resource라는 state를 변경하고 Pending 상태에 진입한다.\n이때 백그라운드에서는 state에 대한 다음 페이지를 준비하는 Receded 상태에 머물러 있을 것이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"잠시 뒤 다음 페이지의 Receded 상태가 끝나고 Skeleton 상태에 진입하면 그때서야 실제 DOM에 적용한다.\nSkeleton 상태는 현 UI 상태인 Pending 상태보다 더 최신 단계이기 때문이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이제 조금 헷갈릴 수 있는 상황이 등장한다.\n테코블 크루의 닉네임과 설명이 모두 렌더링 되어 Complete 상태로 넘어가고 다른 크루의 버튼을 눌러보자.\n버튼을 눌렀을 때 UI가 멈춰있는 Pending 상태에 진입하고 잠시 뒤 Skeleton 상태로 넘어갈 것 같지만\nSkeleton은 등장하지 않고 바로 다른 크루에 대한 정보가 렌더링 되는 Complete 상태로 넘어간다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"여기서 간과하는 사실이 있다. 렌더링 상태는 렌더링을 유발하는 state 관점이라는 것이다.\n"},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"페이지 방문하기"}]},{"type":"text","value":" 버튼을 누르던, "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"크루의 버튼"}]},{"type":"text","value":"을 누르던 resource라는 같은 state의 변경이 일어나고 있다.\n다시 한번 화면을 확인해보자. 크루의 버튼을 누르기 전에 resource state의 관점으로 봤을 때, Pending 상태가 아니라 모든 화면에 정보가 완전하게 보이는 complete 상태다.\n여기서 크루의 버튼을 누르면 Pending 상태나 Skeleton 상태로 전환되지 않는다. 현 UI는 Complete 상태로, Pending이나 Skeleton 상태보다 더 최신 상태이기 때문이다.\n그리고 백그라운드에서 새로운 resource state에 대한 렌더링이 Complete 상태로 넘어갔을 때, 그제야 실제 DOM에 적용한다.\n이전 state에 대한 Complete 상태보다 새로운 state에 대한 Complete 상태가 더 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"최신 상태"}]},{"type":"text","value":"이기 때문이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"🔥 실제로 도입하기"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"지금까지는 concurrent mode가 동작하는 원리를 알아보았다. 이제 concurrent mode를 실제 코드에 적용하기 위해서는 어떻게 해야 할까?\nreact는 이를 위해 "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"useTransition"}]},{"type":"text","value":"이라는 훅을 제공한다. useTransition을 사용한 다양한 패턴이 있지만, 필자가 구현해본 결과\n아직은 useTransition의 가장 간단한 사용법 정도를 훑어보는 정도면 충분할 듯하다. 아직 experimental이라 언제든 실제 구현 코드가 달라질 수 있기 때문이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"오늘 글에서 가장 먼저 예제로 등장했던 blocking mode input을 concurrent mode로 개선해보자.\n먼저 개선한 결과는 다음과 같다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"iframe","properties":{"src":"https://codesandbox.io/embed/concurrent-mode-5-ei5z8?fontsize=14&hidenavigation=1&theme=dark&view=preview","style":"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;","title":"concurrent-mode-5","allow":"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking","sandbox":["allow-forms","allow-modals","allow-popups","allow-presentation","allow-same-origin","allow-scripts"]},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"1. react experimental 버전 설치"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"우선 concurrent mode는 experimental 버전에서만 동작한다. experimental 버전을 설치해주자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"text"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-text"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"npm install react@experimental react-DOM@experimental"}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"2. concurrent 모드 활성화"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"js"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-js"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","comment"]},"children":[{"type":"text","value":"//index.js"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"import"}]},{"type":"text","value":" React "},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"from"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"'react'"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"import"}]},{"type":"text","value":" ReactDOM "},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"from"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"'react-DOM'"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"import"}]},{"type":"text","value":" App "},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"from"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"'./App'"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"const"}]},{"type":"text","value":" rootElement "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"="}]},{"type":"text","value":" document"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"."}]},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"getElementById"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"element","tagName":"span","properties":{"className":["token","string"]},"children":[{"type":"text","value":"'root'"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\nReactDOM"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"."}]},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"createRoot"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"text","value":"rootElement"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"."}]},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"render"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"<"}]},{"type":"text","value":"App "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"/"}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":">"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"기존 blocking mode에서는 ReactDOM.render()를 사용했지만 concurrent mode를 사용하기 위해서는 createRoot()를 사용해야 한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"3. state 반영 우선순위를 정하기"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"우리는 사용자가 input을 입력할 때 버벅거림을 줄이기 위해서 input state의 우선순위를 높게 줄 것이고\n5000개의 렌더링을 위한 array state는 우선순위를 낮게 주어 UI 업데이트가 지연될 수 있도록 할 것이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"❗ 주의 : 2021년 7월 기준 experimental 버전에서 useTransition의 리턴 형태가 [startTransition, isPending] => [isPending, startTransition] 으로 바뀌었다.\n유의하도록 하자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["gatsby-highlight"],"dataLanguage":"js"},"children":[{"type":"element","tagName":"pre","properties":{"className":["language-js"]},"children":[{"type":"element","tagName":"code","properties":{"className":["language-js"]},"children":[{"type":"element","tagName":"span","properties":{"className":["token","comment"]},"children":[{"type":"text","value":"// App.js"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"const"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"["}]},{"type":"text","value":"isPending"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":","}]},{"type":"text","value":" startTransition"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"]"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"="}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"useTransition"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","literal-property","property"]},"children":[{"type":"text","value":"timeoutMs"}]},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":":"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","number"]},"children":[{"type":"text","value":"3000"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":","}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","comment"]},"children":[{"type":"text","value":"// 최대 3초 동안 다음 화면의 렌더링을 백그라운드에서 준비하겠다는 의미. 3초가 지나면 강제로 렌더된다."}]},{"type":"text","value":"\n\n"},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"const"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","function-variable","function"]},"children":[{"type":"text","value":"handleChange"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"="}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","parameter"]},"children":[{"type":"text","value":"event"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"=>"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"setInput"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"text","value":"event"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"."}]},{"type":"text","value":"target"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"."}]},{"type":"text","value":"value"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"startTransition"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"=>"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"{"}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","comment"]},"children":[{"type":"text","value":"// 지연할 UI와 관계된 state를 리액트에게 알려줌"}]},{"type":"text","value":"\n    "},{"type":"element","tagName":"span","properties":{"className":["token","keyword"]},"children":[{"type":"text","value":"const"}]},{"type":"text","value":" newArray "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"="}]},{"type":"text","value":" array"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"."}]},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"map"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"element","tagName":"span","properties":{"className":["token","parameter"]},"children":[{"type":"text","value":"_"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":","}]},{"type":"text","value":" index"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"=>"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","constant"]},"children":[{"type":"text","value":"TECOBLE"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"["}]},{"type":"text","value":"index "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"%"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","constant"]},"children":[{"type":"text","value":"TECOBLE"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"."}]},{"type":"text","value":"length"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"]"}]},{"type":"text","value":" "},{"type":"element","tagName":"span","properties":{"className":["token","operator"]},"children":[{"type":"text","value":"+"}]},{"type":"text","value":" Math"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"."}]},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"random"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n\n    "},{"type":"element","tagName":"span","properties":{"className":["token","function"]},"children":[{"type":"text","value":"setArray"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"("}]},{"type":"text","value":"newArray"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n  "},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":")"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":"}"}]},{"type":"element","tagName":"span","properties":{"className":["token","punctuation"]},"children":[{"type":"text","value":";"}]}]}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"handleChange 내부의 로직을 유심히 보자. setInput은 startTransition 바깥에서 실행되고, setArray는 내부에서 실행되고 있다."},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n이 차이는 state의 우선순위를 결정한다. setArray를 startTransition으로 감싸주는 의미는 ‘array state 변화는 지연시켜도 돼’라고 리액트에게 알려주는 것이기 때문이다.\n따라서 input state는 array state보다 높은 우선순위로 결정된다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 해주는 이유는 사용자의 입력이 5,000개의 DOM element를 렌더링하는 것보다 우선시 되어야 사용자가 입력할 때의 버벅임을 줄일 수 있기 때문이다.\n결과를 확인해보자. 이전 blocking mode로 구현했던 예제보다 훨씬 버벅임이 줄어들었을 것이다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"✨ 마무리"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"오늘은 사용자 경험 개선을 주제로 concurrent mode까지 알아보았다.\n1편에서 다루었던 suspense와는 다르게 concurrent mode는 react의 렌더링 방식을 크게 변화시키는 등\n앱 전반적으로 영향을 미칠 수 있는 터라 아직은 production 코드에서 사용하기에는 다소 무리가 있어 보인다.\n또한 예제 코드를 작성하면서 개인적으로 느낀 것은 concurrent mode를 지원하는 훅이 아직 직관적으로 사용하기가 불편하다는 생각이 들었다.\n(물론 내가 아직 concurrent mode의 개념에 익숙지 않아서 그럴 수는 있다 😂)\n하지만 concurrent mode는 곧 나올 React 18에 적용될 기능이기도 하고, 사용자 경험 개선에 있어서 도입하였을 때 많은 이점을 누릴 수 있는 기능이기에\n미리 공부하는 것이 나중에 큰 도움이 되리라 생각한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"오늘 주제에 관해 공부하면서 사용자 경험의 관점에서 많은 생각을 하게 되었다. 많은 로딩이 사용자 경험에 좋지 않다는 점을 알게 되었고\n디바운스와 쓰로틀에 대해서도 다시 생각해보게 되었다. 역시 무엇이든 완벽한 기술은 없다. 이를 염두에 두고 항상 불편함을 찾으며 개선하려는 자세를 가져야겠다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"참고"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://velog.io/@cadenzah/react-concurrent-mode"},"children":[{"type":"text","value":"What is React Concurrent Mode?"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"element","tagName":"a","properties":{"href":"https://ko.reactjs.org/docs/concurrent-mode-patterns.html"},"children":[{"type":"text","value":"concurrent mode UI 패턴"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"excerpt":"❗ react suspense에 대한 이해가 필요한 글입니다. 사용자 경험 개선 1편을 참고해주세요. 👀 concurrent mode…","timeToRead":6,"frontmatter":{"title":"사용자 경험 개선 2편 - react concurrent mode","userDate":"24 July 2021","date":"2021-07-24T12:00:00.000Z","tags":["react","concurrent-mode"],"excerpt":null,"image":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAcIAwT/xAAWAQEBAQAAAAAAAAAAAAAAAAAGAQL/2gAMAwEAAhADEAAAAakXmy4MpKKOs3f/xAAaEAACAwEBAAAAAAAAAAAAAAACBAMFBgES/9oACAEBAAEFAk4V4RzOnXvG5wbGRpm06hk886FzKx5L/8QAHhEAAgEDBQAAAAAAAAAAAAAAARECACExMkFRgbH/2gAIAQMBAT8BjGK1FhKKsWmyts5HdKPPtf/EAB4RAAICAQUBAAAAAAAAAAAAAAECAxESACIxQlFh/9oACAECAQE/AXklEiqsalCDk5amQjgKtg/Dta761Zybw6//xAApEAACAgEDAgMJAAAAAAAAAAABAgMEEQAFIRITI0FRIjE0YXGRk8HT/9oACAEBAAY/AmLyBERDIxkBICj06eSR5KBk/XV+k0T7duSSTWUo2Th5aQcRJYrSY7c4UCM2Vi+HaVV5X29EK3H3/XpjU6DZpJiYpMNBuNNWz0kcd/tDz+ePfjjVDfb0JqxVaV8U6/fjknln3DwpmsvFJOkcUcIcxQRFoy/PghVR8dB/Mf46/8QAGRABAQEBAQEAAAAAAAAAAAAAAREhAGFB/9oACAEBAAE/IUn/APzYkYDcChxuaeg7CzgoqEoIZHyhdLfDgz4gMb8Jc1QmUg7AkcnCdeXyjkhVNls8333/2gAMAwEAAgADAAAAEA/f/8QAHBEBAQABBQEAAAAAAAAAAAAAARFBITFRYcHw/9oACAEDAQE/EI7BoGmhCwTQEEu4nwx04nePL//EABwRAQEAAgIDAAAAAAAAAAAAAAERACExUUFhsf/aAAgBAgEBPxBTDpxOsOFichKWFN83om523z96M//EABkQAQADAQEAAAAAAAAAAAAAAAEAETEhQf/aAAgBAQABPxAWhjORiKD4VmEYQ7Z8MoL/AIcxBUKkwh6lAniU9GV62TigOevGSjyWeBZaZBpJTgxQ6iQNWGYtz//Z"},"images":{"fallback":{"src":"/static/7780ac375f6cd2a73fcaec55eb1794bf/a3034/concurrent-mode.jpg","srcSet":"/static/7780ac375f6cd2a73fcaec55eb1794bf/1a6a0/concurrent-mode.jpg 750w,\n/static/7780ac375f6cd2a73fcaec55eb1794bf/a34c3/concurrent-mode.jpg 1080w,\n/static/7780ac375f6cd2a73fcaec55eb1794bf/58ec7/concurrent-mode.jpg 1366w,\n/static/7780ac375f6cd2a73fcaec55eb1794bf/a3034/concurrent-mode.jpg 1920w","sizes":"100vw"},"sources":[{"srcSet":"/static/7780ac375f6cd2a73fcaec55eb1794bf/616e4/concurrent-mode.avif 750w,\n/static/7780ac375f6cd2a73fcaec55eb1794bf/87a4b/concurrent-mode.avif 1080w,\n/static/7780ac375f6cd2a73fcaec55eb1794bf/e67d1/concurrent-mode.avif 1366w,\n/static/7780ac375f6cd2a73fcaec55eb1794bf/a3608/concurrent-mode.avif 1920w","type":"image/avif","sizes":"100vw"},{"srcSet":"/static/7780ac375f6cd2a73fcaec55eb1794bf/7ad3f/concurrent-mode.webp 750w,\n/static/7780ac375f6cd2a73fcaec55eb1794bf/ef054/concurrent-mode.webp 1080w,\n/static/7780ac375f6cd2a73fcaec55eb1794bf/55e70/concurrent-mode.webp 1366w,\n/static/7780ac375f6cd2a73fcaec55eb1794bf/431e9/concurrent-mode.webp 1920w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.7442708333333333}}},"author":[{"name":"3기_미키","bio":"우아한테크코스 3기 미키(권세진)입니다 :)","avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#a8c8e8","images":{"fallback":{"src":"/static/fa7f6a0c3d11e8c67baa396cbd962e43/ce903/mickey.jpg","srcSet":"/static/fa7f6a0c3d11e8c67baa396cbd962e43/75695/mickey.jpg 40w,\n/static/fa7f6a0c3d11e8c67baa396cbd962e43/6e519/mickey.jpg 80w,\n/static/fa7f6a0c3d11e8c67baa396cbd962e43/ce903/mickey.jpg 120w","sizes":"100vw"},"sources":[{"srcSet":"/static/fa7f6a0c3d11e8c67baa396cbd962e43/40b58/mickey.webp 40w,\n/static/fa7f6a0c3d11e8c67baa396cbd962e43/a06b5/mickey.webp 80w,\n/static/fa7f6a0c3d11e8c67baa396cbd962e43/43b57/mickey.webp 120w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.75}}}}],"source":"https://unsplash.com/@aleskrivec"}},"relatedPosts":{"totalCount":11,"edges":[{"node":{"id":"7ba5222a-1532-55f6-9207-9adf99b14c6d","timeToRead":6,"excerpt":"…","frontmatter":{"title":"useLayoutEffect를 활용한 산발적 마커 렌더링 최적화","date":"2023-11-21T12:00:00.000Z"},"fields":{"slug":"/post/2023-10-11-marker-rendering-optimization/"}}},{"node":{"id":"08804e81-5841-5b4d-866e-06e495fa7296","timeToRead":4,"excerpt":"들어가며 2022년 3월, React 18이 발표되었습니다. 여러 변경 사항이 있었지만 그 중 핵심은 Concurrency(동시성)입니다. 기존 experimental 버전에서만 동작하던 ‘concurrent mode…","frontmatter":{"title":"React 18 - 동시성 렌더링","date":"2023-07-31T12:00:00.000Z"},"fields":{"slug":"/post/2023-07-09-concurrent_rendering/"}}},{"node":{"id":"96995cff-d71e-568d-b845-ef1e02ffb5af","timeToRead":5,"excerpt":"❗ CSR에 SSR을 적용하는데 어려움을 겪는 분들을 위해 작성했습니다. 혹시 틀린 부분이 있다면 말씀해주세요! ❗ SSR과 refresh token에 대한 사전 지식이 있으면 글을 이해하기 조금 더 편합니다. ❗ 웹서버와 WAS…","frontmatter":{"title":"CSR 앱에서 SSR + CSR 환경으로 이주하기","date":"2021-09-10T12:00:00.000Z"},"fields":{"slug":"/post/2021-09-10-ssr/"}}},{"node":{"id":"190fe582-f002-5988-a9cd-ba5c51240226","timeToRead":4,"excerpt":"…","frontmatter":{"title":"react에서의 에러 처리","date":"2021-08-14T12:00:00.000Z"},"fields":{"slug":"/post/2021-08-13-react-error-handling/"}}},{"node":{"id":"5c0ebfa3-95eb-5637-9e62-2579867587b2","timeToRead":3,"excerpt":"cypress에 대한 기본적인 이해가 필요한 글입니다. 0.Intro 바닐라 자바스크립트에서 cypress를 통해 테스트를 진행한 경험은 있지만, react…","frontmatter":{"title":"Cypress를 활용한 React 테스팅","date":"2021-07-28T12:00:00.000Z"},"fields":{"slug":"/post/2021-07-28-react-cypress-testing/"}}}]}},"pageContext":{"slug":"/post/2021-07-24-concurrent-mode/","prev":{"excerpt":"0. 인트로 클로져를 MDN…","timeToRead":5,"frontmatter":{"title":"클로져와 가까워지기","tags":["closure","javascript"],"date":"2021-07-16T12:00:00.000Z","draft":false,"excerpt":null,"image":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAz0lEQVR42r2SSQvCMBCF/Q2d/P+/4IaIK2grLtSKBa11PXhRcG/r9Tkh1hZRenA5fLyZPPKSCUkdJwLfJPXzwP34jiNwcFQdapy49z7QFfAXzFzgMhPwWIOFqv17LdWL+Sf3TeCZjY0tYJY06BkNwxphWCfoWYLN2swQDK7NkmJicJ8jrPuE8zS66SNQnrTlwHZBg1XhDTqhkSa08oRlR2BQJXTZ6xUJVpngGordKOEN5VjBUo0jua7UeOG6RD6LlzRyyMGJeO5f8f9v82ngDWrQNLKpC+93AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/b9040c0176c571424b9d5c9bb4adbe84/18b2e/closure.png","srcSet":"/static/b9040c0176c571424b9d5c9bb4adbe84/18b2e/closure.png 700w","sizes":"100vw"},"sources":[{"srcSet":"/static/b9040c0176c571424b9d5c9bb4adbe84/377b6/closure.webp 700w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5}}},"author":[{"name":"3기_파노","bio":"우아한테크코스 3기 프론트엔드 파노(전환오)입니다~~!","avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAEyElEQVR42mWS6XNTdRSG89Vthra0SdO0CVBkB0HLLrKJCFWkLAVUQBgGQUfKMjLIIlYYlhkoIIsIWIGytbQUmm5pmzRd0jTNerekCOPyjzyem6J88MM7v5t7J899znuuJRELocQH0JUomhobihZD1xOkkhp//vE7kXAQw1D4+6/nDKY0ua//l8GUTlKemc81TcGiJcIYahRdfQlUBaiocZ4OpjhefhSX08m0t6Zy704Vz58/kz+qAtDQJckX0JT5W1dfAg0t9hKoRBgc1GnztGDNzmbh1CnMHjeGuXPnkUylBGYIzEifJjhlAmUaQ9eGgMn/AcVWi9PZ3sKBz1bhPnaIh+WHuSS2iiKjGTp60kjHMP4dX0vDLZr0lxQjE2r2aNqp8TAx6S0U6Kbp/HG6Tx7BX3GaRHuz1KESTyReQg1zZCOdNFA1FyIAw7QSW0WWFAn18iylUFFxlimFLh7u3kJN+QE+Li7G2+nHEFBCHTI1r58OJoeAYmpJRPvRYgOYpqrAYuE+zJe0ND5mxszZjHY5ufzVJs58s5OM4TZK1mwgFA6hio0JNV4YpiTmgiwmIB4JEjMj10o0hKdJYNNnYcvNx2bLY3zhWEY5R2HPH0mOLZ8Vq0uJxOMCVEloWnrspGkrS7JEQwEiA70MyJihYLcA+7lyvoKcHDuOgpE48l0CGoEtz0WBQB0CHT1uKo3NHhQjSUSRTlVduh3aumVAIME+ScBPoMtLONjFmRM/ikmeQJxpS+eI0QIaQX7BCKxWB+Mmz8Dd3Iqi60Rl6zE545qOpgsw0OOjW0DdXR34va0E5TxZfoQcu4xrLyDHaiff9Sa5eWKZ68AqI0+aNhePt5NoQmFAEhVDM4pYWrr97fg72/D7PHjbmuj1ejj1w+G0XcHIMWRlWbE5RmHNdZKdbcPhHM20mYvo6OwhFBNgXCWc0NKJm8BOseqQ78uMp6UBX7ObC6eOk+cowFU4nizpMnO4lWEZw8XWJi8Zz/T5y+nsCdIXiROKKmmYCY4kZMsdnkY8rW5aBdbkfkTT44dcOXeKwsJCHK4xZNtdZGYOJzMrW6zzyRs1kWVrv6ArGKGnP0ownKA/qkqGbC3N8ok0NtbT0FBH/aNqaqvv8Ovlc0yeNFkW4yBHusuUUYdlZGJ/AfzueAW+/hgdgQhdoQTdYZUeAQcjCSwNT2qpr6+hru4BNQKrvneTQ0fLmTL9XelNAAWFWO3O9HLMXvMnzOLwT7fx9kfwBAbSYF8ohl/SI/csNTV3eVB9l3v3q6h5UMX35cdYvHY7763YTLYs4pU3rLyWVcDrGTZeHZZN0eLVLNlygMv33XT0hWnpDdHWOyAJ4ZVeLbeqfuNW1U3u3L3JufPnWLZ+O0s3fcvsNbsYO/EdtpauY/Wy5ZzYW8aOzdv4YOVGVm7dx4Z9J6lt76LRH8DdGaDR1yOfkh/Ltcrr3Ki8wS/XfubTbbtYuH4XizYeZOL8YhYsnof77GnqTp3Ee+kCB8t2M7loDitkKUs/L+PQxds0+Lqp9fiobfVR39SG5eLVq1yrrOTrsj28vWAlRR9tZ92XByguLeH90lXs2bufHfsOs2f/USbMKGLJmrUs+bCEOYs+oWTnEa7XNnG/0cOdJy3ceuTmH+kLSf9tZqmAAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/10e3eeadb16f7a5deb48a31618a4f496/117b1/fano.png","srcSet":"/static/10e3eeadb16f7a5deb48a31618a4f496/117b1/fano.png 458w","sizes":"100vw"},"sources":[{"srcSet":"/static/10e3eeadb16f7a5deb48a31618a4f496/21264/fano.webp 458w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.9978165938864629}}}}]},"fields":{"layout":"post","slug":"/post/2021-07-16-closure/"}},"next":{"excerpt":"이 글은 자바에서 HTTP 요청을 써봤거나 써보려고 하는 독자를 대상을 작성하였습니다. 스프링 어플리케이션에서 HTTP 요청할 때 사용하는 방법으로 RestTemplate과 WebClient가 있다. 스프링 5.0 이전까지는 클라이언트에서 HTTP…","timeToRead":3,"frontmatter":{"title":"RestTemplate과 WebClient","tags":["spring","resttemplate","webclient"],"date":"2021-07-25T12:00:00.000Z","draft":false,"excerpt":null,"image":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABM0lEQVR42p1TXUsCQRT1f/VH+hH9g3rpKYweUgp8EHuIkmBNCvEhDMOCPlDKyk0tSS1EdstkdXU/ZuY0M5F9a7t3GO4w3Dn33HvuBDDGGF9eLTAp4LyVxUZxAcfNFIau6Q+QMiL9YT2JmdQU5rPTUK6XoZuPE5n/AUiljxbmUNHz8myTITqDtj+GjL0xqDwVkK7GkFRXcdTYQbvX8Mfw86Mb/Qz7tThuny9GiTwDmo4BiwvwMtDgEBuEOtD6DzCsDlxqo2vpXKD+eMD3rKJXosx0dQ25+ja2rpZ4ySvYLAaxW44goYblfYazdnmi74x/AIqgvbt1RPOzstT45aIsWymFoGon0idKYb5Do2n4FfBDEMpZWmgZNTS7ZRDmStVFItFD0YqDe4WDn34R8N+D7fW3vAL5v0taOsC+fAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/3c293acc9d566d487b02ac725dad9edb/d8822/resttemplate.png","srcSet":"/static/3c293acc9d566d487b02ac725dad9edb/9ae6a/resttemplate.png 750w,\n/static/3c293acc9d566d487b02ac725dad9edb/0f80b/resttemplate.png 1080w,\n/static/3c293acc9d566d487b02ac725dad9edb/d8822/resttemplate.png 1310w","sizes":"100vw"},"sources":[{"srcSet":"/static/3c293acc9d566d487b02ac725dad9edb/8d8ff/resttemplate.webp 750w,\n/static/3c293acc9d566d487b02ac725dad9edb/fc98a/resttemplate.webp 1080w,\n/static/3c293acc9d566d487b02ac725dad9edb/a1733/resttemplate.webp 1310w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.5603053435114503}}},"author":[{"name":"3기_영이","bio":"우아한테크코스 3기 영이(최준영)입니다 :)","avatar":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAgFBgn/xAAXAQADAQAAAAAAAAAAAAAAAAACBAUG/9oADAMBAAIQAxAAAAFLHRrsdMJ0jOw06H//xAAaEAADAQADAAAAAAAAAAAAAAADBAUGAQIH/9oACAEBAAEFAl2neWYGpw5W5Tnm7k0sTNdnWpk62KlhpZ2f/8QAIREAAgEDAwUAAAAAAAAAAAAAAQIDBBESBSExABMyYaH/2gAIAQMBAT8BOkVcGUAaIpUPZY/IARju5gsBxfA2a2RFwcdn0vUlYqtKkijYODHZhb3Op+Djr//EACARAAIBAwUBAQAAAAAAAAAAAAECAwUSIQAEERNhMTL/2gAIAQIBAT8B2k1PubdCSZBAiuFMYsDSS9ZBtZnZ2/S/OFznUVRozorNUuosOTG0M3K+G2Nl9wTg6//EACYQAAICAQQBAgcAAAAAAAAAAAIDAQQRBRIUIRMAIgYjMjRBQlH/2gAIAQEABj8C2ARSitEiFpld71XK5eJh1/eEeYJjG5DPb9IY/la/rmmFesrpceuttVZoC4cEu5ZZ5ZWEBifLLLH7ERKXJYOKLdQT8L1jisCq6m8dxDUVkE/cyxqxnBSK5Yzqd+8pOZ9LsBpDI2wcsYOp6iPjZkeOtVbkcaUY3wSiVIx7IjqPQ6cmxxo0RxqaLKC2y2w0mT8yYkQcPXZTu3Yjoe90lFGkGBgZ44Wa4FPc7pWF4A34mImYAc4j89+v/8QAGBABAQEBAQAAAAAAAAAAAAAAAREAITH/2gAIAQEAAT8hAQLEstl+rF5AdP34z3qSuWNf9hf0G8IFaxuChS2UQfD0PzPwdznLPYAJikIdExwrDESd1DOCwhX/2gAMAwEAAgADAAAAEAz/AP/EABgRAQEBAQEAAAAAAAAAAAAAAAERITEA/9oACAEDAQE/EKvrVODxKsRPiPsMMioBEJAZrazl/8QAGBEBAQEBAQAAAAAAAAAAAAAAAREhADH/2gAIAQIBAT8QSRZqgJEa2J2cHaXcGdS+mRAKBas//8QAFhABAQEAAAAAAAAAAAAAAAAAAQAR/9oACAEBAAE/EDv1Odeg2EIuCXvUOY8EoOqE1Li0RTG/5mwvwN3k/nKiFGsYGeM3chsF4W657+WEKt3Nk3//2Q=="},"images":{"fallback":{"src":"/static/56bc06af6518041e013d3ccfaedc1e8e/93fdb/younge.jpg","srcSet":"/static/56bc06af6518041e013d3ccfaedc1e8e/6c918/younge.jpg 750w,\n/static/56bc06af6518041e013d3ccfaedc1e8e/93fdb/younge.jpg 960w","sizes":"100vw"},"sources":[{"srcSet":"/static/56bc06af6518041e013d3ccfaedc1e8e/66907/younge.webp 750w,\n/static/56bc06af6518041e013d3ccfaedc1e8e/55375/younge.webp 960w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.75}}}}]},"fields":{"layout":"post","slug":"/post/2021-07-25-resttemplate-webclient/"}},"primaryTag":"react"}},"staticQueryHashes":["2337738035"],"slicesMap":{}}