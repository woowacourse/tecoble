---
layout: post
title: "인수테스트에서 테스트 격리하기"
author: ["보스독"]
comment: "true"
tags: ["test", "isolation"]
toc: true
---



## 테스트 격리란?

우리는 모든 테스트들이 서로 순서에 상관없이 독립적으로 수행되어야 한다는 것을 알고 있다. 하지만 만약 공통으로 사용하는 데이터베이스 상태가 계속 변한다면, 테스트들은 비결정적인 테스드들로 변해진다.

컨트롤러, 서비스, 도메인 계층은 Mock 프레임워크를 사용하여 실제 데이터베이스를 사용하지 않고도 테스트를 진행하는 방법이 있다. 

또한 테스트 격리를 지원하기위해서 JUnit과 Spring Boot에도 여러 도구들이 준비되어 있다.



## 인수테스트에서 테스트 격리하기

인수테스트란 무엇인가?

사용자 시나리오에 맞춰 서비스가 실제 운영 환경에서 사용될 준비가 되었는지 최종적으로 확인하는 테스트이다.

인수테스트의 특징은 다른 계층 처럼 우회적으로 데이터베이스를 사용하지 않음으로써 테스트를 격리하는 방법을 사용할 수 없다. 인수테스트의 목적자체가 실제 운영 환경과 같은 조건에서 테스트 되길 기대하기 때문에 실제 데이터베이스를 사용해야 그 조건을 충족할 수 있다.

그렇기 때문에 테스트가 진행됨에 따라서 데이터베이스의 상태는 계속 변하게 될 것이고, 매 테스트마다 초기상태가 달라지기 때문에 테스가 잘 격리되고 있다고 말하기 힘들것이다.

실제로 개발을 해보면서 인수테스트를 진행하면 똑같은 테스트임에도 불구하고 실행할 때마다 성공여부가 달라지는 경험을 해본 적이 있을 것이다. 테스트가 진행되는 순서와 데이터베이스 초기상태가 보장되지 않기 때문에 이런 문제가 발생한 것이다.

그렇다면 인수테스트에서 효과적으로 테스트를 격리하는 방법은 어떤 것이 있는지 한번 알아보자.

### 1. @Transactional

결론부터 말하면 @Transactional 어노테이션을 사용해서 트랜잭션을 롤백하는 전략은 인수테스트에서는 사용할 수 없다.

많은 사람들이 @Transactional 어노테이션을 붙이면 트랜잭션이 끝난 뒤 커밋하는게 아니라 디폴트로 롤백이 실행된다고 알고 있다. 틀린말은 아니다. 하지만, 인수테스의 경우 @SpringBootTest 어노테이션에 port를 지정하여 서버를 띄우게되는 데 이때, Http 클라이언트와 서버는 각각 다른 스레드에서 실행된다. 따라서 아무리 테스트 코드에 해당 어노테이션이 있다고 하더라도 호출되는 쪽은 다른 스레드에서 새로운 트랜잭션으로 커밋하기 때문에 롤백전략이 무의미해지는 것이다.

### 2. 매 테스트 수행 이후 생성한 픽스처 및 데이터 삭제

<img src="/Users/yeonseok/Library/Application Support/typora-user-images/image-20200920233853864.png" alt="image-20200920233853864" style="zoom:30%;" />



테스트에 필요한 데이터를 @BeforeEach나 테스트 안에서 생성한 뒤, 테스트가 종료되는 시점에서 @AfterEach에 생성한 데이터를 삭제하는 요청으로 데이터베이스를 이전과 같은 상태로 맞추는 방법이다.

아마 테스트에 필요한 데이터가 적은 경우 간단한 방법이기 때문에 많은 사람들이 사용하는 방식이기도 하다.

그러나 이 방법은 생성해야할 데이터가 많거나, 연관관계 맵핑이 있을 경우 비효율이 발생할 수 있다.

먼저 위와 같이 Question을 생성할 때 Hashtag도 같이 입력받아서 생성하는 경우, 명시적으로는 Question만 생성을 했지만 부수적으로 Hashtag까지 테이블에 변화를 주게 된다.

이는 도메인에 대한 지식이 없는 사람이라면 테스트를 작성하면서 연관관계 맵핑으로 생성되는 엔티티를 추적하는 비용이 추가적으로 필요하게된다.

또 다른 문제는 삭제 "요청"을 보내는데, 예를들어 질문 한 개를 생성할 때는 10개의 포인트가 필요한데, 각각의 포인트는 5개의 좋아요를 받을 때마다 얻을 수 있다고 해보자. 그러면 질문하나를 생성할 때 필요한 의존성은 어쩔 수 없다 치더라도, 테스트 격리만을 위해서 반대 요청을 추가적으로 더 보내야한다는게 비효율을 발생하는 것이다.



### 3. 매 테스트 이후 Truncate 쿼리로 모든 테이블 초기화

앞서 살펴본 delete로 테이블을 초기화하는 방법보다는 상당히 괜찮은 방법이다.  API요청도 필요없고, delete를 하기위해서 하나씩 select(조회)를 할 필요도 없다. 뿐만아니라 쿼리를 수행하는데 있어서 트랜잭션 로그공간을 적게 사용하고, delete는 매 행마다 락을거는데 그에 비해 truncate은 락을 거는 수가 상대적으로 적어서 빠른 시간에 우리가 원하는 테이블 초기화를 이뤄줄 수 있다.

여기서도 두가지 방식으로 trucate 쿼리를 실행할 수 있다.

#### 1) @Sql 어노테이션

- 스프링부트에서 제공하는 어노테이션으로 클래스 테스트가 실행되기 전에 @Sql이 가리키는 파일안의 SQL문을 모두 수행하고나서 테스트를 시작한다. 파일하나와 어노테이션만으로 테스트 격리를 이뤄낼 수 있으니 획기적인 방식이라고 볼 수 있다.

  하지만 한가지 단점은 엔티티 혹은 연관관계 테이블이 추가될 때마다 테스트 격리를 위해서 파일을 수정해주어야 한다는 점이다. 매번 추가하는 것도 번거롭지만, 엔티티가 많은 경우 무엇을 빼먹었는지 수정하고 찾는 과정에서 비효율을 예상해 볼 수 있다.

#### 2) EntityManager로 직접 truncate 쿼리 실행

이 방식은 sql 파일을 직접 실행시키기보다 JPA에서 쿼리를 수행하는 EntityManager를 빈으로 주입받고, 모든 테이블 이름을 조사해서 각각의 인수테스트가 시작할 때, truncate 쿼리를 실행시킬 수 있다. 

<img src="/Users/yeonseok/Library/Application Support/typora-user-images/image-20200920235418072.png" alt="image-20200920235418072" style="zoom:40%;" />

![image-20200920235443008](/Users/yeonseok/Library/Application Support/typora-user-images/image-20200920235443008.png)





## 결론

이렇게 인수테스트에서 효과적으로 테스트를 격리시킬 수 있는 방법을 알아보았다. 단순히 테크닉 적인 내용보다는, 테스트 격리의 정의가 무엇이고, 왜 인수테스트는 격리를 위한 장치가 필요한지 그 의미를 스스로 생각해보면 앞으로 테스트 코드를 작성하는데이도 도움이 될 것이라고 생각한다.

