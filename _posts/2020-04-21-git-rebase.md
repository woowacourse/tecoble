---
layout : post
title : git rebase로 보기 좋은 커밋 메시지 만들기.
author : "카일"
---

## 정의

특정한 프로그램을 개발하는 경우 일반적으로 `기능` 을 기준으로 커밋을 작성한다. 이런 경우 기능을 단위로 커밋을 작성하는 것은 어렵지 않다. 하지만 기능 구현을 완성하고 리팩토링 혹은 변경사항이 발생하였을 때 커밋의 단위나 메시지가 애매해지는 경향이 많다. 이 글에서는 커밋의 단위가 애매해지는 원인과 해결에 대해서 얘기해보고자 한다.

## 문제

- 기능 단위의 커밋은 설계 단계에서 상대적으로 명확하게 작성하고 개발을 시작하기 때문에 Commit 단위를 분리하기가 쉽다. **그러나 변경에 있어서 커밋의 단위가 애매한 경우가 많이 발생한다.**

## 변경 단위가 왜 애매해지는가?

1. 변경에 대한 설계가 없는 상태에서 변경을 시작한다.
    - 살아 있는 [README.md](http://readme.md) 가 아니다. 기능을 개발할 때는 기능 목록에 따라 개발을 하지만 수정의 경우 눈앞에 보이는 부분을 리팩토링 하다 보면 추가적으로 리팩토링할 것들이 연쇄적으로 발생한다. 이러한 경우 커밋의 단위가 애매해지기 좋은 상황이다.

2. 변경에 있어서 커밋의 크기가 다르다. (작은 부분을 수정해도, 큰 부분을 수정해도 하나의 커밋이다)
    - 1번에서 언급한 것과 같이 프로그램은 객체 간의 상호 의존성으로 인해 하나의 수정은 다른 수정을 야기하는 경향이 있다. 이런 경우 커밋의 단위가 과하게 커질 수 있으며 반대로 컨벤션 수정과 같은 부분은 작은 단위로 분리된다.

## 해결

1. **변경에 대한 설계가 우선되어야 한다.**
    - 일반적으로 변경 및 리팩토링은 설계 없이 시작하는 경우가 많다. 이 경우 변경 도중 어떤 식으로 변경이 확장되고 변경될지 알 수 없기 때문에 커밋의 단위가 애매해지는 경우가 자주 발생한다. **따라서 변경하고자 하는 부분을 설계하고 이를 단계적으로 분할하여 [README.md](http://readme.md) 에 작성한 후  다시  분할한 단위별로 커밋을 하려는 의도적 노력이 필요하다.**
2. **커밋을 단위로 묶는 방법을 사용한다.**
    - 위와 같은 방법을 사용하더라도 변경 과정에서 예상치 못한 추가 변경 사항은 발생하기 마련이다. 이 경우 추가 변경 사항에 대해서 **작은 단위로 커밋을 찍은 후 전체 구조를 확인한 후 같은 내용 혹은 포함하는 내용의 커밋을 하나로 합치는 방법을 사용한다.**
    - 이때 사용할 수 있는 방법이 아래의 키워드들이며 구체적인 사용법은 → [여기](https://json.postype.com/post/209499) 를 통해 확인할 수 있다.
        - `git rebase -i`
        - `squash`
        - `force push`
    - 추가적으로 Commit을 합치는 과정에서 커밋 로그를 통해, 혹은 순서를 통해서 합치는 것이 일반적인데 Git 에서 제공하는 `Tag`기능을 이용하면 보다 직관적으로 커밋을 관리할 수 있다. [Git 태그를 활용한 보다 쉬운 커밋 합치기!](https://git-scm.com/book/ko/v2/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%ED%83%9C%EA%B7%B8)

    - 브랜치를 분할해서 수정 후 병합하는 형태
        - 실제 현업에서 사용하는 git 전략을 부분적으로 도입함으로써 개발, 리팩토링, 등의 과정을 명료하게 표현할 수 있다.
        - 브랜치를 분할하여 세부적으로 커밋을 찍고 이를 dev 혹은 master에 병합하는 과정에서 하나의 커밋으로 합쳐지기 때문에 명료해진다 .
            - 큰 변화 단위를 보고 싶은 경우 rebase message 를 확인
            - 세부적인 커밋 단위를 보기 위해서는 rebase 내부에 있는 커밋 메세지들을 확인

## 예시

- 도메인 관련 수정
    - 상황 : Knight 객체에서 `move` 메서드를 수정하고자 한다. 그런데 수정하던 도중 getter의 필요성이 생겨 getter도 추가해야 하는 상황
    - 해결
        - move 메서드를 수정하고 **(세세한 커밋 작성)**
        - getter 메소드를 추가한다. **(세세한 커밋 작성)**

        <img width="695" alt="git_commit1" src="https://user-images.githubusercontent.com/49060374/79834399-f9cf0700-83e7-11ea-9ea6-e01262b5b965.png">

        - 이 둘의 커밋을 하나로 합친다. 아래와 같이 하나의 커밋 메세지 안에 (Knight 관련 수정(move,getter)) 합쳐진 커밋 메시지를 함께 볼 수 있다.  → **보다 일반화된 단위로 커밋 병합**

        <img width="610" alt="git_commit2" src="https://user-images.githubusercontent.com/49060374/79834395-f8054380-83e7-11ea-840d-64716508cf66.png">

    - 위와 같은 방식으로 수정에서 발생하는 사소한 부분들을 Commit을 하고 최종적으로 하나의 단위의 변경이 끝났다고 생각되는 경우 `rebase , squash` 를 통해 하나의 커밋으로 합쳐서 `push` 한다.
    - 이렇게 하는 경우 위에서 언급한 것처럼 전체적인 수정 사항을 한눈에 볼 수 있고**(일반화된 단위의 커밋)** 전체적인 수정 사항을 이루고 있는 작은 커밋 단위**(세세한 커밋 내역)**에 대해서도 확인할 수 있기 때문에 변경에 대해 미시적, 거시적으로 둘 다 확인 할 수 있다.

## 결론
- 간단한 방법을 통해 조금은 커밋 로그를 보기 쉽게 하는 법을 설명했지만 커밋 로그를 잘 작성하는 것은 매우 어려운 일이다. 간단한 예시 통해 설명하였지만 복잡한 현업에서는 이와 같은 방법으로는 충분하지 않을 것이다. 커밋 로그를 잘 찍기 위한 추가적인 학습이 필요해 보인다.