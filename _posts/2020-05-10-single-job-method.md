---
layout: post
title: "하나의 메서드는 하나의 기능을 수행하자"
author: "보스독"
---



우리는 프로그래밍을 하면서 수많은 메서드들을 작성한다. 

그렇다면 우리가 작성하는 프로그래밍에서의 메서드란 무엇일까? 

> ```
> 객체 지향 프로그래밍(OOP)에서 메서드는 객체와 관련된 프로시저이다. 객체는 데이터와 동작으로 구성되고 데이터 및 행동은 인터페이스를 포함한다. 따라서 메서드는 클래스 안에서 정의되며, 인터페이스는 서로 협력하는 객체간의 메시지를 보낼 수 있도록 지정한다.
> 
> - From wikipedia - 
> ```

이처럼 객체 지향 프로그래밍에서 메서드는 객체간의 협력하는 구조를 설계하기 위해서 반드시 필요한 객체의 행동에 해당한다. 하지만 우리는 객체간의 복잡한 협력과 그 기능을 구현하는 메서드를 다루다 보면 길이가 길어지고 한번에 여러 기능을 수행하는 메서드를 작성하는 경우가 생긴다. 

여기서 우리는 주의를 해야할 필요가 있다. 메서드 수를 줄이고 한 메서드 안에 여러 기능을 구현하는 것이 더 좋은 프로그래밍 방법일까?

**답은 NO다.**

우테코 크루의 자동차 경주 미션 코드 중 일부를 발췌한 다음 예시를 통해 문제점을 알아보자. 

```java
// Cars.java in racingcar
...

public void moveAllCarOneTime() {
    for (Car car : raceCars) {
        car.increasePositionOrNot(Util.getRandomNumber());
        if (car.checkGreaterThanMaxPos(maxPosition)) {
            ++this.maxPosition;
        }
    }
}
...
```

 `moveAllCarOneTime` 메소드를 들여다보자. 무슨 기능을 하는 메서드인지 단번에 알겠는가?

메서드 명만 보면 **모든 자동차에 대해 increasePositionOrNot 메서드를 실행**하는 것으로 이해할 수 있다. 과연 정말 그럴까?

내부를 들여다보면 반복문을 돌며 `increasePositionOrNot` 메서드를 실행하고 있지만, `checkGreaterThanMaxPos`라는 메서드를 실행하여 Max Position을 확인하고, 그 값을 업데이트까지 해주고 있다.

물론 Max Position은 우승자를 구하는 로직에 쓰이는 중요한 값이지만, `moveAllCarOneTime` 메서드가 가지고 있어야 할 책임은 분명 아니다.

이 코드를 작성한 사람은 추후에 Max Position을 구하기 위해서 어차피 반복문을 돌아야 하기 때문에 한번에 처리하고 싶은 의도였을 것이다. 하지만 우승자를 구하는데 필요한 로직은 별도의 함수를 통해 작성되어야 할 것이다.

위 예시 코드를 통해 찾은 문제점은 다음과 같다.

> 1. 메서드 명이 메서드의 기능을 포괄하지 못하고 있다.
> 2. 요구사항으로 변경 시  `moveAllCarOneTime`  메서드를 수정해야 한다.
> 3. 반환 값이 없고 두 가지 기능을 수행하고 있기 때문에 테스트하기 어렵다. 

아직은 기능의 규모가 작기 때문에 문제점들이 마음에 크게 와닿지 않을 수 있다. 하지만 규모가 확장되고 구현해야 하는 로직이 복잡해진다면 위 문제들도 점점 더 커지게 될 것이다.

따라서 우리는 유지보수를 쉽게하고 의사소통 비용을 줄이기 위해 매우 상습적으로 클린 코드를 지향해야 할 필요가 있다. 이는 궁극적으로 객체지향 프로그래밍을 더 효과적으로 활용할 수 있는 발판이 되기 때문이다. 

그렇다면 **메서드를 하나의 기능만 구현하도록 코드를 명료하게 작성**하면 어떤 점이 좋은 지 정리해보자.



### 메서드 명만 보더라도 어떤 기능을 수행하는 메서드인지 명확하게 알 수 있다.

기능의 단위가 짧고 명확할 수록 기능을 대변하는 이름 짓기도 수월하지 않겠는가?

잘 지은 메서드 명은 코드의 가독성이 증가시키고 유지보수를 수월하게 해준다. 이름의 길이는 중요하지 않다. 축약된 단어를 쓰지 말고, 메서드가 수행하는 기능을 잘 대변할 수 있는 이름을 짓는 것이 중요하다. 

메서드 네이밍 컨벤션도 지키며 코드를 작성하면 많은 도움이 될 것이다. 메서드 네이밍 컨벤션에 대한 자세한 내용은 [메서드 네이밍 컨벤션](https://woowacourse.github.io/review/2020-04-26/Method-Naming) 글을 참고하자.



### 코드의 재사용이 증가하여 유지보수가 용이해진다.

메서드가 하나의 기능만 수행하는 작은 단위가 될 수록 여러곳에서 쉽게 가져다 쓸 수 있다. 레고 블럭을 생각하면 이해가 쉽다. 단일 블럭은 어느 곳이든 사용될 수 있지만, 여러 블럭이 붙어 커진 블럭은 쉽게 재사용하지 못한다. 

위에서 본 예시 코드에서도 우승자를 구하는게 아닌 꼴찌를 구하는 요구사항으로 변경되었다고 가정해보자. 결과를 구하는 것과 전혀 관련이 없어보이는  `moveAllCarOneTime` 메서드에서 코드의 변경이 일어나야 할 것이다.

하지만 Max Position을 구하는 메서드를 따로 분리하여 결과를 구하는 메서드에서 사용한다면 우승자와 관련된 요구사항이 변경될 때마다 해당 결과를 구하는 클래스의 메서드에서만 코드를 변경이 일어나기 때문에 응집도를 높일 수 있고 결과적으로 유지보수가 용이해진다.



### 단위 테스트가 수월해진다.

테스트 주도 개발(TDD)을 한다면 우리는 특정 기능을 구현할 때 테스트를 먼저 작성할 필요가 있고, 따라서 대부분의 메서드는 단위테스트가 있어야 한다.

`moveAllCarOneTime`의 테스트 코드는 어떻게 작성되었을까? 어떤 값을 검증해야 할까?

아니. 그전에 검증을 제대로 할 수 있을지 생각해봐야 한다. car의 특정 메서드를 실행함과 동시에 `maxPosition`이라는 전역변수의 값을 변경하고 있다. 테스트를 수행하는 동안 전역변수의 값이 변하지 않는다고 보장할 수 있을까? 

또한 메서드가 반환 값이 없는 타입이기 때문에 `maxPosition`을 확인하는 테스트를 작성하기 어려울 것이다. 

maxPosition을 구하는 `findMaxPosition`이라는 메서드를 분리한다면 다음과 같은 테스트를 추가적으로 작성할 수 있다.

``` java
// Cars.java
public void findMaxPosition() {
  return cars.stream()
        .mapToInt(Car::getPosition)
        .max()
        .getAsInt();
}


// CarsTest.java
@DisplayName("Max Position 확인")
@Test
public void maxPosition() {
  Car car1 = new Car("c1");
  
  car1.increasePositionOrNot(4);
 	car1.increasePositionOrNot(5);
  
  Cars cars = new Cars(Arrays.asList(car1));
  
  assertThat(cars.findMaxPosition()).isEqualTo(2);
}
```



### 결론 

하나의 메서드는 하나의 기능을 하도록 구현하면 위에서 살펴본 장점들을 확보할 수 있을 뿐만아니라 전체적인 가독성도 높아진다. 우리는 글을 읽을 때도 짧은 단락으로 구성된 글이 긴 장문의 글보다 더 읽기 쉽고 이해하기도 쉽다는 것은 누구나 알고있는 사실이다.

메서드를 작성할 때 가장 좋은 라인 수는 5~10줄이라고 한다. 가능한 10줄 이내의 길이로 하나의 기능을 가진 메서드를 작성하는 연습을 통해 우리 모두 클린 코더가 되어보자.

---

#### 읽어볼 만한 문서

[Long Method](https://refactoring.guru/smells/long-method)

[Clean Coding in Java](https://www.baeldung.com/java-clean-code)

[Composing Method](https://refactoring.guru/extract-method)

