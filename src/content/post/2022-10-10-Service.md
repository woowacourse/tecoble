---
layout: post
title: 서비스 추상화
author: [4기_연로그]
tags: ['service', 'test']
date: '2022-10-10T12:00:00.000Z'
draft: false
image: ../teaser/abstract-art.jpg
---

# 😘 서론

우아한테크코스에서 사용하는 협업 도구 중 하나인 Slack은 무료 프리티어를 이용하는 경우 3개월이 지난 메시지들을 보여주지 않습니다.
레벨 3 팀 프로젝트인 [줍줍](https://github.com/woowacourse-teams/2022-pickpick)에서는 이 사라지는 메시지들을 백업해주는 서비스를 제공합니다.
Slack의 메시지에 대한 정보를 주로 다루다 보니 자연스레 Slack 라이브러리에 의존적인 로직이 많아졌습니다.
이 포스팅에서는 외부 라이브러리(Slack 라이브러리)를 사용하는 로직들을 어떻게, 왜 추상화했는지에 관해 이야기를 하려고 합니다.

<br/><br/>

# 🤔 왜 서비스를 추상화해야 하는가?

<img src="../images/2022-10-10-slack.png" width="30%"/>

기존의 테스트에서는 Slack 라이브러리를 호출하는 부분은 모킹 처리를 해두었습니다.
테스트 코드를 리팩토링 하다 보니 모킹 작업이 계속 `반복`되는 `지루`한 작업 같다는 생각이 들었습니다.
반복되는 모킹 작업을 제거하기 위해 테스트 방식을 `목`에서 `스텁`으로 변경해야겠다는 결심을 하게 되었습니다.
(테스트에 대한 이야기는 `2기_스티치`의 [Test Double을 알아보자](https://tecoble.techcourse.co.kr/post/2020-09-19-what-is-test-double/)를 참고
바랍니다.)

 스텁용 객체를 만들기 위해서는 Slack 라이브러리의 `MethodsClient`라는 인터페이스를 구현해야 합니다.
해당 인터페이스는 약 250개의 메서드를 갖고 있었고 그중 저희 서비스에서 실제로 사용하는 메서드는 약 10개 정도에 불과했습니다.
**필요한 부분만** 개발자의 의도대로 수행할 수 있도록 작업하기 위해 외부 라이브러리에 대한 로직들을 추상화하는 작업을 진행했습니다.

<br/><br/>

# 😆 예제 코드

## 1. 외부 라이브러리를 쓰는 로직 추상화

예제로 채널을 생성하는 `ChannelCreateService`의 기존 로직을 가져와 보았습니다.
자세한 로직을 이해할 필요는 없으나 로직의 대부분이 Slack 라이브러리에 의존하고 있는 것을 확인하실 수 있습니다.

```java
public Channel createChannel(final String channelSlackId) {
  try {
    // slack api를 호출하는 부분
    Conversation conversation=slackClient
        .conversationsInfo(request -> request.channel(channelSlackId))
        .getChannel();
  
    // slack의 response를 우리 도메인인 channel 형태로 변환
    Channel channel = toChannel(conversation);
  
    // channel을 저장하고 return
    return channels.save(channel);

  } catch(IOException|SlackApiException e) { // slack api 호출로 인해 발생할 수 있는 exception
    throw new SlackApiCallException("conversationsInfo");
  }
}
```

위 로직을 아래처럼 두 개의 클래스로 분리하여 역할을 나눠주었습니다.

- `ChannelCreateService`: Channel 저장 로직을 가진 클래스

```java
public Channel createChannel(final String channelSlackId) {
  Channel channel = slackClient.callChannel(channelSlackId);
  return channels.save(channel);
}
```

- `CallSlackApi`: Slack 라이브러리 호출하는 클래스

```java

@Component
public class CallSlackApi {

  private final MethodsClient methodsClient;

  public CallSlackApi(final MethodsClient methodsClient) {
    this.methodsClient = methodsClient;
  }

  public Channel callChannel(final String channelSlackId) {
    try {
      // Slack 라이브러리를 호출
      Conversation conversation = methodsClient.conversationsInfo(
          request -> request.channel(channelSlackId))
        .getChannel();

      // 결과값을 우리가 사용하는 객체 형태로 변경
      return new Channel(conversation.getId(), conversation.getName());

    } catch (IOException | SlackApiException e) {
      throw new SlackApiCallException("conversationsInfo");
    }
  }
}
```

<br/>

## 2. 추상화한 로직 인터페이스로 분리

좀 더 편리한 스텁 객체를 만들기 위해 인터페이스로 만들었습니다.
기존의 `CallSlackApi`에 존재하던 로직은 `ExternalClient`이라는 인터페이스를 구현한 `SlackClient`로 옮겨줬습니다.

- `ExternalClient`

```java
public interface ExternalClient {
  Channel callChannel(String channelSlackId);
}
```

- `SlackClient`: ExternalClient의 구현체

```java

@Component
public class SlackClient implements ExternalClient {

  public Channel callChannel(final String channelSlackId) {
    try {
      Conversation conversation = methodsClient.conversationsInfo(
          request -> request.channel(channelSlackId))
        .getChannel();

      return new Channel(conversation.getId(), conversation.getName());

    } catch (IOException | SlackApiException e) {
      throw new SlackApiCallException("conversationsInfo");
    }
  }
}
```

<br/>

## 3. 스텁용 빈 생성 및 적용

스텁용 빈을 생성한 뒤 테스트에 적용합시다.
단순히 `@Component`만 적용하면 `ExternalClient` 타입의 bean이 2개 등록됩니다.
해당 예제의 경우에는 `@Primary`를 통해 `FakeClient`의 우선순위가 더 높도록 조정했습니다.

```java

@Primary
@Component
public class FakeClient implements ExternalClient {

  private List<Channel> channels = List.of( ...); // 채널 데이터 초기화

  @Override
  public Channel callChannel(final String channelSlackId) {
    return channels.stream()
      .filter(it -> it.sameSlackId(channelSlackId))
      .findAny()
      .orElseThrow(() -> new SlackApiCallException("test-callChannel"));
  }

}
```

<br/><br/>

# 😉 마무리

해당 글에서는 테스트를 간편화하기 위해 서비스 추상화를 진행해보았습니다.
서비스 추상화는 이 외에도 다양한 목적으로 진행할 수 있습니다.

객체지향적인 코드는 `단일 책임 원칙`을 준수합니다.
기존의 `ChannelCreateService`에서는 Slack의 API를 호출하고 호출하다가 예외가 발생하면 예외 처리도 해주고 Channel 정보를 저장도 하는 등 여러 일을 하고 있었습니다.
개선된 `ChannelCreateService`에서는 `SlackClient`를 통해 채널 정보를 불러오고, 이를 DB에 저장하는 역할을 합니다.
Slack API를 호출하고 예외 처리를 해주는 등의 작업은 `SlackClient`으로 옮겨갔습니다.
이후에 호출해야 하는 API를 변경하면 `SlackClient`에서 로직을 변경해주면 됩니다.

이렇듯 서비스를 추상화하면 이전보다 코드가 **간결**해지고 작업하려는 **목적이 분명**하게 드러납니다.
각 오브젝트의 책임과 역할이 더 분명하게 분리되어 변경 사항이 생기는 경우 **변경 포인트를 쉽게 찾아낼 수 있**습니다.

<br/><br/>

***

### Referernces

- 토비의 스프링 3.1 - chapter 5 서비스 추상화 / 이일민
- cover image: 피에트 몬드리안의 추상화 작 `브로드웨이 부기우기`
