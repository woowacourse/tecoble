---
layout: post
title: 'SWR, 서버 데이터를 로컬 데이터처럼 관리해보자'
author: [3기_미키]
tags: ['refactoring']
date: '2021-05-23T12:00:00.000Z'
draft: false
image: ../teaser/swr.jpg
---

프론트엔드는 `서버의 데이터를 어떻게 표현할 것인가?` 라는 문제가
가장 큰 문제라고 해도 과언이 아니다.

서버 데이터를 앱에 가져와서 상태를 관리하는 방법.
이를 위해 Redux를 적용해본 경험이 다들 꽤나 있을 것이다.

하지만 Redux로 서버 데이터를 관리하면서 불편함을 느낀 적이 한 두번이 아닐 것이다.
그래서 오늘은 서버 데이터 관리의 불편함의 사례와 이를 해소할 수 있는 `SWR`에 대해서 알아보도록 하자.

## 😭 Redux. 서버 데이터 관리가 불편해요

### 👎 fetch 후 Redux 상태에 담는 코드가 복잡하다.

fetch 후 데이터를 어딘가에 저장해야하므로 Redux를 활용해 전역으로
상태를 관리하는 상황이 많이 발생한다.

다음은 해당 기능을 수행하는 Hook이다.

```js
//action.js
export const GET_ITEMS = 'data/GET_CART_ITEMS';
export const GET_ITEMS_SUCCESS = 'data/GET_CART_ITEMS_SUCCESS';
export const GET_ITEMS_ERROR = 'data/GET_CART_ITEMS_ERROR';

export const thunkLoadItems = () => async (dispatch) => {
  dispatch({ type: GET_ITEMS });

  try {
    const items = await fetch(...);

    dispatch({ type: GET_ITEMS_SUCCESS, payload: items });
  } catch (error) {
    dispatch({ type: GET_ITEMS_ERROR, payload: error });
  }
};

//reducer.js
const reducer = (state = initialState, action) => {
  switch (action.type) {
    case GET_ITEMS:
      return {
        ...state,
        isLoading: true,
        error: null,
      };
    case GET_ITEMS_SUCCESS:
      return {
        ...state,
        items: [...action.payload],
        isLoading: false,
      };
    case GET_ITEMS_ERROR:
      return {
        ...state,
        error: action.payload,
      };

      ...
  }
}

```

정보를 fetch하여 전역 상태에 담는 하나의 동작만을 간단히 구현하기 위해서
액션 타입을 작성하고, 그에 대응되는 thunk 함수와 reducer 코드를 작성해야한다.

여기서 request와 관련된 동작을 추가적으로 구현할 때마다
위와 비슷한 코드를 반복적으로 작성해야한다.
이런 작업을 반복하면서 개발자는 번거로움을 느끼고 코드는 점점 복잡해진다.

### 👎 상태 초기화를 위한 코드가 중복된다.

장바구니 목록을 3개의 페이지에서 사용한다면
아래와 같은 코드를 작성해야할 것이다.

```js
// actions/cart.ts
export const thunkGetCartItems = () => async dispatch => {
  dispatch({ type: GET_CART_ITEMS });

  try {
    const items = await requestShoppingCartItemList();
    dispatch({ type: GET_CART_ITEMS_SUCCESS, payload: items });
  } catch (error) {
    dispatch({ type: GET_CART_ITEMS_ERROR, payload: error });
  }
};

// ex) page1.tsx, page2.tsx, page3.tsx
useEffect(() => {
  dispatch(thunkGetCartItems());
}, []);
```

페이지마다 모두 상태를 초기화하기 위한 메서드를 넣어주어야 한다.
물론 커스텀 훅에 useEffect를 포함시켜 추상화할 수 있겠지만 그렇게 구현하는데에도 비용이 많이 든다.

여기서 추가적으로 1분마다, 또는 네트워크가 재연결되었을 때 데이터를 갱신시켜주어야한다면?
이제 코드는 점점 복잡해지기 시작한다.

이런 문제들이 발생하는 건 태생부터 Redux가 서버 상태 관리를 위한 라이브러리가 아니기 때문이다.
Redux는 추적가능한 `로컬` 상태 관리 라이브러리다.
그래서 비동기적인 작업에 약한 Redux는 미들웨어로 이를 해결하는 등 여러가지 대안이 나오고 있지만 여전히 불편하다.
그럼 SWR은 어떤 녀석이길래 이 문제를 해결해 준다는 것일까?

## 😎 SWR. 넌 누구냐!

SWR은 `stale-while-revalidate`의 약자다.
이는 [HTTP 리소스에 대한 명세 - RFC 5861](https://datatracker.ietf.org/doc/html/rfc5861)에서 정의한
'stale-while-revalidate' 전략에서 따온 것이다.

그렇다면 'stale-while-revalidate'은 무엇일까?
[mdn](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cache-Control)에서는 다음과 같이 표현하고 있다.

> stale-while-revalidate=\<seconds\>
>
> 비동기 적으로 백그라운드 에서 새로운 것으로 체크인하는 동안 클라이언트가 **최신이 아닌 응답을 받아 들일 것**임을 나타냅니다.
> 초 값은 클라이언트가 최신이 아닌 응답을 받아 들일 시간을 나타냅니다.

'stale-while-revalidate' 이라는 이름 처럼
SWR는 내부적으로 request를 보냈을 때 우선은 캐시로부터 stale(오래된) 정보를 먼저 리턴하고
백그라운드에서 fetch request(revalidate)를 보내는 전략을 사용하고 있다.

좀 어렵게 다가올 수 있다. 그리고 이런 의문이 들 수 있다.

`SWR이 그래서 대체 뭐가 좋은데?`

사용하는 개발자 입장에서 와닿는 것은 결국 라이브러리의 **편의성**이기 때문에
빠르게 **SWR을 왜 사용하는지**에 대한 주제로 넘어가보자.

## 🙄 SWR. 그래서 왜 사용하나요?

### 1. 서버 데이터를 로컬 상태 처럼 사용

SWR도 캐싱을 통해 데이터를 전역 상태로 관리 한다고 볼 수 있다.
하지만 Redux와 다른 점은 서버 데이터를 로컬 상태처럼 사용할 수 있다는 점이다. (Redux의 상태 추적은 SWR 단독으로는 불가)

```js
const fetcher = url => fetch(url).then(r => r.json());

function App() {
  const { data, error } = useSWR('/api/data', fetcher);
  // ...
}
```

useSWR은 첫번째 인자로 `key`
두번째 인자로 `fetcher`를 받는데
key는 다른 서버 데이터와 구분할 수 있는 이름과 request를 보낼 주소로 사용된다.

key가 같다면 앱 어디서든지 '/api/data'에 대한 데이터를 가져올 수 있다.
전역 상태처럼 가져다 쓸 수 있어 매우 편리하다.

### 2. 상황에 따른 data fetching를 편리하게 사용할 수 있다.

```js
const { data, error } = useSWR('https://api.github.com/repos/vercel/swr', fetchCurrentTime, {
  refreshInterval: 1000,
});
```

이렇게 작성만 하면 1초마다 한 번씩 자동으로 데이터를 갱신할 수 있다.

또한 브라우저에 Focus를 하면 정보를 갱신하는 것이 default 설정으로 들어가 있고
이 외에도 `특정 상황`에 정보를 갱신할 수 있는 옵션들이 굉장히 많다. [(참고)](https://swr.vercel.app/docs/options)

직접 구현했다면 상당히 복잡했을 기능을 한 줄의 옵션으로 바로 적용이 가능하니
굉장한 이점이라고 할 수 있다.

### 3. fetch data가 캐쉬, 공유되기 때문에 불필요한 request를 줄일 수 있다.

```jsx
function useUser(id) {
  const { data, error } = useSWR(`/api/user/${id}`, fetcher);

  return {
    user: data,
    isLoading: !error && !data,
    isError: error,
  };
}

function Content() {
  const { user, isLoading } = useUser(1);
  if (isLoading) return <Spinner />;
  return <h1>Welcome back, {user.name}</h1>;
}

function Avatar() {
  const { user, isLoading } = useUser(1);
  if (isLoading) return <Spinner />;
  return <img src={user.avatar} alt={user.name} />;
}
```

위는 SWR를 사용해 response를 받아오는 예시 코드이다.
코드를 보면 SWR을 통해 request를 보내고 user의 정보를 받아오는
useUser()가 여기저기서 호출되고 있다.
하지만 SWR은 request의 중복을 자동으로 제거해주기 때문에
useUser()가 여러번 호출된다해도 한번만 request가 이루어진다.
이는 의미없는 request를 줄여 서버의 부하를 줄여준다.

그리고 정보에 대한 갱신이 필요하다면 `mutate(key)` 메서드를
사용해 추가적인 request를 수행할 수 있다.

## 출처

[REDUX를 넘어 SWR로(1)](https://tech.madup.com/swr-intro1/)

[Redux 말고 SWR](https://snyung.com/content/2021-01-09--SWR)

[Keeping things fresh with stale-while-revalidate](https://web.dev/stale-while-revalidate/)
